% !TEX root = ../agglo_clust_review.tex

\section{Introduction}
The clustering of weighted graphs has been successfully applied to such tasks as image segmentation, tracking... \UPDATE{REFS}
Most graph clustering methods work with positive edge weights only, representing similarities or distances between the nodes. These methods are parameter-based and require users to specify the desired numbers of clusters or a termination criterion (e.g. spectral clustering or iterated normalized cuts) or even a stronger version of supervision in terms of seeds (e.g. seeded watershed or random walker).  
Hierarchical clustering is a popular graph clustering method, which creates a hierarchy of clusters. Hierarchical agglomerative clustering (HAC) is a bottom-up approach starting with each node assigned to its own cluster and incrementally merging clusters while moving up the hierarchy \cite{lance1967general}. This method usually requires the user to choose a level in the cluster hierarchy defining the desired output clustering. 

Other graph clustering methods work with so-called \emph{signed graphs}, which include both positive and negative edge weights corresponding to attraction and repulsion between nodes. The advantage of using signed graphs over positive-weight graphs is that balancing attraction and repulsion allows us to perform the clustering without defining additional parameters. This can be done optimally by solving the so-called \emph{multicut optimization} or \emph{correlation clustering} problem \cite{kappes2011globally,chopra1991multiway}. However, this problem is NP-hard, so instead of finding optimal solutions, most of the methods perform approximations. Greedy agglomerative clustering algorithms are among the most efficient methods \cite{keuper2015efficient,levinkov2017comparative,wolf2018mutex,kardoostsolving}. 
% Some of these methods \cite{levinkov2017comparative,wolf2018mutex} dynamically introduce cannot-link constraints, representing mutual exclusion relationships between clusters. 

Thus, greedy agglomerative clustering algorithms for signed graphs have clear advantages: they are parameter free and efficient. Despite the fact that there exist a variety of these algorithms, there has been no overarching studies comparing them and making it possible to choose the most appropriate algorithm for particular applications and assess their properties, e.g. robustness and efficiency.


%Despite their similarity to agglomerative HC algorithms for unsigned graphs with only positive weights, neither an explicit connection nor a clear experimental comparison was proposed so far.

In this paper, we propose a novel theoretical framework for generalizing over the greedy agglomerative clustering algorithms for signed graphs by linking these algorithms to HAC. This framework defines an underlying basic algorithm and allows us to explore its combinations with different linkage criteria and \emph{cannot-link constraints}, i.e. mutual exclusion between clusters, in a consistent way. These different combinations then correspond to existing clustering algorithms as well as allows us to introduce and explore new algorithms. The framework can also be easily expended to accommodate additional linkage criteria.

%As a first contribution, we reformulate several of these recently proposed graph agglomerative algorithms in a simple review framework (Sec. \ref{sec:general_framework}) that represents a generalization of agglomerative HC to graphs with both attractive and repulsive edge weights (see Figure \ref{fig:intro_figure} for a visual abstract). From this new point of view, agglomerative HC and algorithms proposed in \cite{levinkov2017comparative,wolf2018mutex,lance1967general,kardoostsolving} all share a general procedure but differ in the way inter-cluster interaction is updated after each iteration (Table \ref{tab:linkage-criteria}). At the same time, we also show that this framework allows us to introduce totally new variations of these algorithms. 
%Ultimately, by presenting this simple general approach, our hope is to motivate a deeper understanding of the connection between algorithms for unsigned and signed graphs.

We then evaluate and compare these algorithms on \emph{instance segmentation}, which is a computer vision task consisting in assigning each pixel of an image to an object instance. %, where the number of instances is usually not known in advance. 
We use a CNN to predict the edge weights of a graph such that each node represents a pixel of the image, similarly to \cite{liu2018affinity,lee2017superhuman,wolf2018mutex}, and provide these weights as input to the algorithms in our framework.
% For our experiments, we focus on a \emph{proposal-free} deep learning method that does not involve object detection but directly group pixels into object instances. 
Recently, there has been a growing interest for such \emph{proposal-free} methods that do not involve object detection, since in certain types of data objects cannot be approximated by bounding boxes.
%  (for example in electron microscopy (EM) image volumes of neurons \cite{arganda2015crowdsourcing})

 
By applying this method both to 2D urban scenes from the CityScapes dataset and the challenging neuron-segmentation task of 3D EM image stacks, \UPDATE{we show how one of the less-known algorithms included in our framework consistently outperformed all other previously proposed signed graph clustering methods and achieved comparable/superior scores to other complex multi-step pipelines...}

Contributions: generalized framework given by simple algorithm; proof of equivalence with previously proposed methods; new algorithms included; on instance image segmentation, one of the less-known methods in our methods achieved remarkable scores compared to previously aggl. methods proposed; comparable scores to much more complex multi-step pipelines; extensive set of experiments with noise, highlighting the properties of different agglomerative methods; over-clustering and under-clustering

% Most recently, success in instance segmentation (IS) has been achieved by applying deep learning and there are two main types of successful deep learning approaches to IS: proposal-based \cite{he2017mask,dai2016instance,li2017fully} and proposal-free \cite{kong2018recurrent,novotny2018semi,kulikov2018instance,kirillov2017instancecut} methods. Proposal-based methods consist of two steps: detecting objects, for example by finding bounding boxes, and assigning pixels to the detected instances. Although these approaches have proven to be highly successful in instance segmentation competitions like MS COCO \cite{lin2014microsoft}, Pascal VOC2012 \cite{everingham2010pascal} and CityScapes \cite{cordts2016cityscapes}, they are not applicable to certain types of data, for example electron microscopy (EM) image volumes of neurons \cite{arganda2015crowdsourcing}, where objects are not approximated well by bounding boxes. 
% More motivation: They are at the same time limited by the quality of the object detection routine, which is hard to train on small datasets (but no ref for this)
% Thus, there is a growing interest for more efficient proposal-free methods that perform IS by directly predicting \UPDATE{pixel features} and then grouping pixels into object instances. In this work, we focus on a common proposal-free method, where a Convolutional Neural Network (CNN) predicts affinities representing how likely it is for pairs of pixels to belong to the same instance. Recently, this approach was successfully applied both to neuron segmentation of 3D EM image stacks \cite{lee2017superhuman,wolf2018mutex} and instance segmentation of 2D urban scenes \cite{liu2018affinity}, where it achieved performances superior and comparable, respectively, to proposal-based methods.
% In this approach, the output of the CNN can be represented as a weighted grid graph such that each node represents a pixel of the image and the weights of the edges define interactions between the pixels. A graph clustering algorithm is then applied to cluster pixels into instances. 
% Finally, the algorithms included in the framework are evaluated on an instance segmentation task, both on 3D biological image stacks (Sec. \ref{sec:neuro_segm_exp}) and 2D urban scenes (Sec. \ref{sec:cityscapes_exp}). Our analysis highlights strengths and weaknesses of each algorithm by comparing their robustness to noise, efficiency and inclination to output a well balanced graph partitioning.



\begin{figure}[t]
\centering
% \includegraphics[width=0.5\textwidth,trim=0.4in 1.2in 0.in 0.05in,clip]{./figs/intro_image.jpg} % left bottom right top
\includegraphics[width=\textwidth]{./figs/intro_image.pdf} % left bottom right top
\caption{
 (\textbf{a}) Iterations of three different algorithms in the generalized framework on  toy graph examples with attractive (green) and repulsive (red) interactions. (\textbf{b}) Example of CREMI 2016 neuron-segmentation data \cite{cremiChallenge} overlaid with instance segmentation. (\textbf{c}) Agglomeration order, representing which pairs of neighboring pixels were merged first (white), later on (brown), or never (black).
 \TODO{show nice segmentations, affinities and replace unsigned case}
%We note how similar linkage criteria, like \emph{Sum} (in the middle) and \emph{Average} (on the right), lead to strongly different merging orders. 
% On the left: a single cluster is returned with only attractive interactions.
 % main ideas and contributions
\label{fig:intro_figure}}
\end{figure}
