% !TEX root = ../agglo_clust_review.tex

\begin{minipage}[t]{\textwidth}
        \centering
        \begin{minipage}[t]{0.45\textwidth}
\centering
        \includegraphics[width=\textwidth,trim=0.1in 0.4in 0.2in 0.2in,clip]{./figs/edge_contraction.png} % left bottom right top
\captionof{figure}{{\small 
Example of edge contraction. The first row represents the original graph $\mathcal{G}$, the clustering $\Pi$ (purple lines) and the edges not on the cut (highlighted in green) before and after the contraction. The second row shows the corresponding contracted graph $\mathcal{G'}$ and cannot-link constraints (edges with red bars). In step (b), edge $e_{uv}$ is contracted: nodes $u$ and $v$ are merged and $e_{uv}$ is deleted from $\mathcal{G'}$. In (c), the two double edges $e_1$ and $e_2$ left in $\mathcal{G'}$ after the contraction are replaced by a single constrained edge with updated cost $f(c_1, c_2)$, where $f$ is one of the update rules defined in Table \ref{tab:linkage-criteria}.} 
\label{fig:edge_contraction_and_contr_graph} }
    \end{minipage}\hspace{0.04\textwidth}
    \begin{minipage}[t]{0.45\textwidth}
        \centering
\includegraphics[width=0.8\textwidth,trim=0.in 0.in 0.in 0.in,clip]{./figs/cannot-lin-constraints.jpg}
\captionof{figure}{\small 
Example of agglomerative clustering on signed graph with and without cannot-link constraints...
\label{fig:algorithm_with_without_CLC}}
    \end{minipage}
\end{minipage}


\section{Generalized framework for Agglomerative Clustering of Signed Graphs}
In this section we introduce the Unified Graph Agglomerative Clustering Algorithm (UGACA) that represents a simple \UPDATE{generalized} formalization of many agglomerative graph clustering algorithms. \UPDATE{It can be used to describe both unsigned clustering algorithms ingesting positive node similarities and signed clustering algorithms using attractive and repulsive cues.}\\
First, we define notation and the concept of cannot-link constraints. Then, we introduce the generalized algorithm and show \UPDATE{how it can be used to introduce several new agglomerative clustering algorithms for graphs with signed edge weights.}

\subsection{Notation and graph formalism} \label{sec:notation}

Given a simple graph $\mathcal{G}(V,E)$, we call the set $\Pi$ a \emph{clustering} with $K$ clusters if $V = \cup_{i=1}^K S_i $, $S_i \cap S_j = \emptyset$ for every $i\neq j$ and every $S \in \Pi$ induces a connected subgraph of $\mathcal{G}$.

In this work, we consider the problem of clustering a weighted graph $\mathcal{G}(V,E,w^+, w^-)$ with both attractive and repulsive edge attributes. The weight function $w^+: E \rightarrow \mathbb{R}^+$ associates a positive scalar attribute $w_e^+\in \mathbb{R}^+$ to each edge $e \in E$ representing a merge affinity or a similarity measure: the higher this number, the higher the inclination of the two incident vertices to be assigned to the same cluster\footnote{Note that several formalisms defining positively weighted graphs associate to each edge a positive scalar that represents a metric or distance on the graph. In these formalisms, the \emph{lower} the edge weight, the higher the attraction between the two linked nodes, contrary to our definition of $w^+: E \rightarrow \mathbb{R}^+$.}. On the other hand, $w^-: E \rightarrow \mathbb{R}^+$ associates a split tendency $w_e^- \in \mathbb{R}^+$ to each edge: the higher this weight, the greater the desire of the incident vertices to be in different clusters. 
Often, graphs with both attractive and repulsive edge attributes are described in terms of a \emph{signed} cost function $\cost: E \rightarrow \mathbb{R}$ that combines both edge weights into one signed scalar number: 
\begin{equation}
\cost_e = w_e^+ - w_e^- \in \mathbb{R}, \quad \quad \forall e \in E
\end{equation}
Graphs that have only positive weights can be clearly seen as special cases of the previously defined graph $\mathcal{G}(V,E,w^+,w^-)$, when $w^-_e=0$ and $c_e \geq 0$ for every $e \in E$.

\paragraph{Linkage criterion}\label{par:linkage_criterion_def} We call two clusters $S_1,S_2$ \emph{adjacent} if there exists at least one edge $e_{uv}\in E$ in the original graph connecting a node $u\in S_1$ to a node $v\in S_2$:
\begin{equation}
 \text{$S_1, S_2 \in \Pi$ are \emph{adjacent}} \quad \Longleftrightarrow  \quad  \mathcal{B}(S_1,S_2) \equiv \{ e_{uv} \in E | u \in S_1, \, v \in S_2 \} \neq \emptyset
\end{equation}
where we defined the set of edges connecting two adjacent clusters as \UPDATE{\emph{boundary}} \UPDATE{$\mathcal{B}(S_1,S_2)$}. The interaction between two clusters $S_1, S_2$ is usually defined as a function, named \emph{linkage criterion}, depending on the weights of all edges in the boundary $\mathcal{B}(S_1,S_2)$. In hierarchical agglomerative clustering and graphs with only positive weights, some examples of linkage criterion statistics are \emph{maximum} (single-linkage clustering), \emph{minimum} (complete-linkage clustering) and arithmetical average (average-linkage clustering).

\paragraph{Multicut and correlation clustering} For any clustering $\Pi$ of $\mathcal{G}$, we define as $E^0_\Pi$ the set of edges linking nodes in the same cluster, and as $E_\Pi^1$ the complementary set of edges whose linked nodes belong to distinct clusters:
\begin{equation}
E_\Pi^0 \equiv \{ e_{uv} \in E \,|\, \exists S \in \Pi : u \in S \, \text{and} \, v \in S \}, \qquad E^1_\Pi \equiv E \setminus E^0_\Pi.
\end{equation}
% \begin{align}
% E_\Pi^0 &= \{ e_{uv} \in E \,|\, \exists S \in \Pi : u \in S \, \text{and} \, v \in S \}, \\
% E^1_\Pi &= E \setminus E^0_\Pi.
% \end{align}
The set of edges $E_\Pi^1$ is known as the \emph{multicut} of $\mathcal{G}$ associated to the clustering $\Pi$. The instance of the NP-hard \emph{weighted correlation clustering} or \emph{minimum cost multicut problem} w.r.t. $\mathcal{G}(V,E,w^+, w^-)$ \cite{kappes2011globally,chopra1991multiway,andres2015lifting} is the task of finding a clustering that optimally balance the attraction and repulsion in the graph and is given by the following optimization problem/binary integer program:
\begin{equation}
% \min_\Pi \texttt{MC}(\Pi) \equiv
 \min_\Pi \sum_{e\in E} \cost_e x_e^\Pi,  \qquad \text{where} \quad x^\Pi_e = 
 \begin{cases} 
 1 & \text{if } e\in E^1_\Pi \\
 0 & \text{otherwise}.
 \end{cases}
\end{equation}
In the next chapters we will use this objective as a way to measure how balanced is a clustering found by the tested agglomerative clustering algorithms.

\begin{algorithm}[t]
  \caption{Generalized Agglomerative Clustering Algorithm for Signed Graphs}
   \hspace*{\algorithmicindent} \textbf{Inputs:} graph $\mathcal{G}(V,E,W)$; boolean {\color{blue}\texttt{addCannotLink}}  \\
  \hspace*{\algorithmicindent} \textbf{Outputs:} Final clustering $\Pi$ and contracted graph $\mathcal{G}'$\\
  \hspace*{\algorithmicindent} 
  \begin{algorithmic}[1]
    % \Procedure{SignedGraphEdgeContr}{{\color{blue}bool \emph{addConstraints}}}
      % \State $\mathcal{G}'\gets \mathcal{G}(V,E^+ \cup E^-)$ \Comment{Initialize the contracted graph}
      \State Initialize clustering $\Pi=\{\{v_1\}, \ldots, \{v_N\}\}$ and contracted graph $\mathcal{G}' \gets \mathcal{G}$
      \State Initialize \texttt{canBeMerged}$[e] \gets$ \texttt{True} $\,\,\, \forall e\in E$
      \State Sort edges in priority queue (PQ) in descending order of absolute costs $|w^+_e - w^-_e|$ 
      \State
      \While{PQ is \textbf{not} empty}
        \State Pop edge $e_{uv}$ in $\mathcal{G}'$ with highest absolute cost $|\cost|$
        \If{({\color{ForestGreen}\textbf{$\cost > 0$}}) \textbf{and} \texttt{canBeMerged}$[e_{uv}]$}
          % \State PQ, $\,E_\dagger,\,\, E' \gets$ \textsc{deleteDoubleEdges}($u,v$)
        %   \State Update costs of double edges;
        %   \State Propagate constrained flags of double edges;
          \State Contract $e_{uv}$ in $\mathcal{G}'$ and merge clusters in $\Pi$
          \For{every new pair of double edges $(e_1,e_2)$}
            % \State Get costs $\cost_1, \cost_2$ of $e_1,e_2$
            \State Delete $e_2$ from $\mathcal{G}'$ and update cost of $e_1$ with update rule $f(\cost_{e_1},\cost_{e_2})$ def. in Tab. 1 
            % \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} update priority of $e_1$
            % \State Delete $e_2$ from $\mathcal{G}'$
          \EndFor
          % \State  Replace double edges in $\mathcal{G}'$ with single edges
          % \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} and update priorities
        \EndIf
        % \State
        \If{({\color{red}\textbf{$\cost \leq 0$}}) \textbf{and} {\color{blue}\texttt{addCannotLink}}}
          % \State Flag $e_{uv}$ as MustNotLink
          \State \texttt{canBeMerged}$[e_{uv}] \gets$ \texttt{False}
        \EndIf
      \EndWhile
      % \For{$e  \in E$ in descending order of absolute costs $|W(e)|$}
      %   \If{({\color{ForestGreen}\textbf{$W(e) > 0$}}) \textbf{AND} (edge is not constrained)}
      %     \State Contract edge $e$ in the graph $\mathcal{G}'$;
      %     \State Update costs of double edges;
      %     \State Propagate constrained flags of double edges;
      %     % \For{every new double edge}
      %     %   \State Delete double edges
      %     %   \State Insert new one with updated cost
      %     % \EndFor
      %   \EndIf
      %   \If{({\color{red}\textbf{$W(e) \leq 0$}}) \textbf{AND} ({\color{blue}\emph{addConstraints}})}
      %     \State Flag edge $e$ as constrained
      %   \EndIf
      % \EndFor
      % \State
      \State
      \Return $\Pi$, $\mathcal{G}'$
      % \State


    % \EndProcedure

  \end{algorithmic}
  \label{main_alg}
\end{algorithm}


\subsection{Generalized agglomerative clustering framework} \label{sec:algorithm}

We now present our main contribution: a generalized framework for agglomerative graph clustering that can describe in a simple form several graph partitioning algorithms previously introduced in the literature and highlights the existence of new ones.

Given a graph $\mathcal{G}(V,E,w^+, w^-)$, the proposed generalized clustering uses a bottom-up approach starting with each node assigned to its own cluster and iteratively merging pairs of adjacent clusters. Intuitively, the algorithm starts by merging clusters with the strongest attractive interaction, corresponding to the highest positive weights in the graph, and it stops when the remaining clusters share only mutual repulsive interactions (see Fig. \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}b} and \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}c}). 

A second variant of the proposed algorithm also introduces \emph{cannot-link constraints}, representing mutual exclusion relationships between pairs of nodes that cannot be associated with the same cluster in the final clustering. This variant (Algorithm \ref{main_alg} with \texttt{addCannotLink=True}) stops when all the remaining clusters have been previously constrained.


% The algorithm that we will present in the next section iteratively performs a sequence of so-called \emph{edge contractions} on the original graph $\mathcal{G}(V,E,w^+, w^-)$.

% The graph clustering algorithm we will present in Sec. \ref{sec:algorithm} is a bottom-up approach starting with each node assigned to its own cluster and iteratively merging clusters. During the agglomeration, the current clustering $\Pi$ is represented by a \emph{contracted graph} $\mathcal{G'}(\mathcal{G}, \Pi)$, such that each of its nodes represents a cluster $S \in \Pi$ and \emph{adjacent} clusters are linked by an edge. 

\paragraph{Edge contraction and update rules} During the agglomerative process, the interaction between adjacent clusters has to be properly updated and recomputed.  % given by the linkage criterion defined in Sec. \ref{sec:notation} and
An efficient way of implementing these updates can be achieved by representing the clustering $\Pi$ with a \emph{contracted graph} $\mathcal{G'}(\mathcal{G}, \Pi)$, such that each of its nodes is associated to a cluster $S \in \Pi$, edges represent adjacency-relationships between clusters and edge weights inter-cluster interactions.
\UPDATE{Every time a pair of neighboring clusters is merged, the contracted graph is updated by performing an edge contraction and merging two nodes. After the edge contraction, the only cluster interactions that need to be updated are those between nodes connected by double edges in the contracted graph (see Fig. \ref{fig:edge_contraction_and_contr_graph}, step b). For simple linkage criteria, these updates can be easily computed with an update rule $f$ that depends only on the interactions at the previous step }
% As a result, the merged node could be linked to some of its neighbors by double edges . , representing the fact that their interaction should be updated. This update can be easily achieved by using an \emph{update rule} depending only on the weights of the double edges. 
\TODO{such a mess...}
\UPDATE{In this way we do not need to recompute the interaction by using the linkage criterion over all the edges of the original graph, that would be computationally expensive.}


\paragraph{The algorithm} The proposed Algorithm \ref{main_alg} proceeds as follows. Given an initial clustering $\Pi$ where each node of the original graph $\mathcal{G}$ represents its own cluster  \TODO{repetition}, the algorithm starts by initializing a contracted graph $\mathcal{G}'$ (see Definition \ref{def:contr_graph}) that will represent the clustering $\Pi$ at each iteration of the agglomeration. The algorithm then sorts all edges $e\in E$ by their absolute weight $|W(e)|$ in descending order in a priority queue, so that the most attractive and the most repulsive edges are processed first. It iteratively pops one edge $e_{uv}$ from priority queue and, depending on the value of the priority $\tilde{w}$ associated with $e_{uv}$, does the following: if the edge is attractive and $\tilde{w}>0$, then merge the connected nodes and perform an edge contraction of $e_{uv}$ in $\mathcal{G}'$ (see Sec. \ref{sec:notation} and Fig. \ref{fig:edge_contraction_and_contr_graph}), provided that $e_{uv}$ was not previously flagged as a cannot-link constraint; for every new pair of double edges in $\mathcal{G}'$ update \UPDATE{their priorities} according to one of the update rules listed in Table \ref{tab:linkage-criteria} and update their cannot-link relationships (see example in Fig. \ref{fig:algorithm_with_without_CLC}b from step 3 to 4). If, on the other hand, the edge $e_{uv}$ is repulsive and $\tilde{w}\leq 0$, then flag it as a cannot-link constraint if and only if the algorithm input-option \texttt{addCannotLink} is true and mutual exclusion relationships should be enforced.
In the Supplementary material we provide a more detailed description of the algorithm (Sec. \ref{sec:detailed_algorithm}) and we also comment on its computational complexity (Sec. \ref{sec:complexity}).

 In the special case of a graph with only positive edge interactions, i.e. $w_e^-=0$ $\forall e\in E$, %$\mathcal{G}(V,E,W:E\rightarrow \mathbb{R}^+)$ 
 the algorithm performs a standard agglomerative hierarchical clustering by returning only one single cluster (see Fig. \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}a}) and a hierarchy of clusters defined by the order in which the clusters were merged. 
 %\TODO{use def of merging process of contracted graph to define merging tree?}.

% \item Comment about must-not-link relations: they give high priority to the most confident repulsive edges {}


% Given a clustering $\Pi$ and a graph $\mathcal{G}(V,E,W)$, the interaction between two clusters $S_1, S_2 \in \Pi$ is usually defined in terms of a \emph{linkage criterion}, i.e. a function of all the edge weights connecting the two clusters:
% \begin{equation} 
% \begin{gathered}
% \mathcal{L}(S_1,S_2) = \mathcal{L}(\mathcal{W})\quad \\
%    \text{where} \quad \mathcal{W} = \{ W(e_{uv})| u\in S_1, v\in S_2 \}.
% \end{gathered}
% \end{equation}


\begin{table*}
    \centering
    \begin{subtable}[t!]{\textwidth}\centering
        \begin{tabular}{r l || c | c | c}
            % \toprule\toprule
             & &  \multirow{3}{*}{\textbf{Unsigned graphs}}  & \multicolumn{2}{c}{\textbf{Signed graphs}}  \\        
            % \cmidrule(l{.15em}){4-5}
            % \cline{4-5}
            & & &  \multicolumn{2}{c}{\thead{Add Cannot-Link Constraints:}} \\        
           
            & & &  \thead{\textsc{No}} & \thead{\textsc{Yes}} \\        
            % \cmidrule[0.3em]{3-5}
            % \midrule[0.15em]
            \midrule\midrule
            Sum: & \thead[l]{$f(\tilde{w}_1,\tilde{w}_2) = \tilde{w}_1+\tilde{w}_2$} & \thead{Sum Linkage\\Hierarchical Aggl.\\Clustering} & \thead{Greedy Additive \\ Edge Contraction \\\cite{levinkov2017comparative}} & \thead{Greedy \\Fixation \\\cite{levinkov2017comparative}} \\ \midrule
            
            \makecell[r]{Abs. \\ max:} & \thead[l]{
            $
            f(\tilde{w}_1,\tilde{w}_2) = \begin{cases} 
            \tilde{w}_1 & \text{if}\,\, |\tilde{w}_1|>|\tilde{w}_2|\\
            \tilde{w}_2 & \text{otherwise}
             \end{cases} 
            $}
               & \thead{Single Linkage\\Hierarchical Aggl.\\Clustering \cite{lance1967general}} & \thead{Mutex \\Watershed \\\cite{wolf2018mutex}} & \thead{Mutex \\Watershed \\\cite{wolf2018mutex}} \\ \midrule
            \makecell[r]{Mean:} & \thead[l]{$f(\tilde{w}_1,\tilde{w}_2) = \mathrm{weightAvg}\{ \tilde{w}_1, \tilde{w}_2 \} $}                                 & \thead{ Average Linkage\\ Hierarchical Clust. \\(UPGMA) \cite{lance1967general}} & \thead{Average Linkage\\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Max: & \thead[l]{$f(\tilde{w}_1,\tilde{w}_2) = \max \{ \tilde{w}_1, \tilde{w}_2 \}  $}                                 & \thead{Single Linkage\\Hierarchical Aggl.\\Clustering \cite{lance1967general}} & \thead{Single Linkage \\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Min:& \thead[l]{$f(\tilde{w}_1,\tilde{w}_2) = \min \{ \tilde{w}_1, \tilde{w}_2 \}  $}                                 & \thead{Complete Linkage\\ Hierarchical Aggl.\\Clustering \cite{lance1967general}}  & \thead{Complete Linkage \\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}



            
        \end{tabular}
        % \caption{Linkage criteria}
    \end{subtable} 
    \caption{The table lists all the algorithms that can be seen as special cases of the Generic Agglomerative Clustering \ref{main_alg} given a specific update rule $f(e_1,e_2)$ and a type of graph...}
    \label{tab:linkage-criteria}
\end{table*}


\subsection{Update rules and associated algorithms}
\begin{itemize}
\item In this section we will list some of the algorithms that can be described using the generalized Algorithm \ref{main_alg} presented above \UPDATE{and we will introduce some new ones}.
\item In Table \ref{tab:linkage-criteria} we collected the update rules that we tested and compared in this article. Later we will mention more of them that were proposed in the literature.
\item In the special case of unsigned graphs (Table \ref{tab:linkage-criteria} column 1), the UGAC algorithm becomes simply a version of hierarchical clustering with different linkage criteria depending on the chosen update rule. It outputs one single cluster and it also defines a hierarchy of clusters during the merging process that can be associated to \UPDATE{a merging tree/  the hierarchical clustering dendrogram}... \TODO{Problem: sum does not trivially define an ultra-metric-distance...}  
\item In the literature there have been already several methods using cannot-link constraints for agglomerative clustering algorithms \TODO{repetition from related work}: for example, \cite{malmberg2011generalized} used initially fixed mutual exclusion relationships, whereas \cite{levinkov2017comparative} introduced them dynamically in an edge contraction algorithm for signed graphs, named Greedy Fixation (Table \ref{tab:linkage-criteria} row 1, \emph{sum}). At the same time, they also proposed a version of it without cannot link constraints (Greedy Additive Edge Contraction) and they compared both with other greedy and local-search algorithms for solving the multicut/correlation clustering problem.
\item Dynamically introduced cannot-link constraints were also proposed by \cite{wolf2018mutex}, that... \TODO{brief MWS description as efficient implementation of this update rule}. In the Supplementary material we show that the algorithm they present can be seen as a special case of UGACA with absolute maximum update rule (Table \ref{tab:linkage-criteria} row 2 - \emph{absolute maximum}) and that adding or not cannot-link constraints does not change the final clustering.
\item On the other hand, the signed graph versions of UGACA with update rules \emph{arithmetic mean}, \emph{max} and \emph{min} (rows 3 to 5 in Table \ref{tab:linkage-criteria}) are new algorithms that were never mentioned in the literature, \UPDATE{especially those with cannot-link constraints}.
\item In this article, we test and run a comparison of the five types of update rule listed in Table \ref{tab:linkage-criteria} (i.e. \emph{sum}, \emph{absolute max}, \emph{arithmetic mean}, \emph{max} and \emph{min}), since \UPDATE{they they are the most commonly used and the cheapest to compute}. Nevertheless, UGACA can be easily generalized to include even more complex rules. For instance, \cite{nunez2013machine} proposes a learned version of update rule where a neural network updates the edge weights depending on edge and node features; another really common choice is to introduce a weight regularization depending on the size of the linked nodes (\cite{felzenszwalb2004efficient} and \cite{kardoostsolving} (unpublished...??), Thorsten..); 
\cite{funke2018large} on the other hand accumulate statistics for each \UPDATE{boundary between clusters} by keeping a discrete histograms of the edge weights and then computes quantiles from it.
\end{itemize}


% \begin{table*}[t]
%     \centering
%     \begin{subtable}[t!]{0.98\textwidth}\centering
%         \begin{tabular}{c | c }
%             \toprule\toprule
%             \makecell{Algorithm name} & \makecell{Algorithm description and \\linkage criteria}    \\
%             \midrule\midrule

%             Weighted Arithmetic Mean (WPGMA) & \thead{Assign a weighting $\alpha_e \in \mathbb{R}^+$, $\forall e \in E$ \\ \\ Linkage criteria: $w_{\mathrm{new}} = \frac{\alpha_1 w_1 +\alpha_2 w_2}{\alpha_1 + \alpha_2} $}  \\ \midrule
            
%             \makecell{Felzenszwalb Efficient \\Graph-based Image Segmentation \cite{felzenszwalb2004efficient}}  & \thead{Initially all edges have positive weights }  \\ \midrule

%             \makecell{Quantile Agglomeration Clustering (...?)}  & \thead{...}  \\ \midrule

%             \makecell{Graph-based active learning \\of agglomeration (GALA) \cite{nunez2013machine}}  & \thead{Assign set of edge features $\phi^{\mathrm{I}}_e$ and \\node features $\phi^{\mathrm{II}}_u$, $\forall u \in V$, $\forall e \in E$. \\ \\ A classifier $f$ with parameters $\theta$ predicts and updates\\ the cost of an edge: $w_e = f(\phi^{\mathrm{I}}_e, \phi^{\mathrm{II}}_u, \phi^{\mathrm{II}}_v; \theta)$, $\forall e_{uv} \in E$} \\ \midrule

%             % \makecell{$w_{\mathrm{new}}=w_{\tilde{e}}$,$\,
%             % \,$ where $\tilde{e}=\mathrm{arg}\max_{e\in \{e_{1},e_{2}\}} \left|w_e\right|$  }  & \thead{Mutex Watershed \cite{wolf2018mutex}} & \thead{Mutex Watershed \cite{wolf2018mutex}} \\ \midrule

%             % Arithmetic mean: $w_{\mathrm{new}} = (w_1+w_2) / 2 $                                 & \thead{Hierarchical Clustering \\ with Average Linkage (UPGMA)} & \thead{\textbf{NEW}}\\ \midrule

%             % Maximum: $w_{\mathrm{new}} = \max \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Single Linkage} & \thead{\textbf{NEW}}\\ \midrule

%             % Minimum: $w_{\mathrm{new}} = \min \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Complete Linkage} & \thead{\textbf{NEW}}



            
%         \end{tabular}
%         % \caption{Linkage criteria}
%         \label{tab:linkage-criteria}
%     \end{subtable} 
%     \caption{Linkage criteria 2}
% \end{table*}






