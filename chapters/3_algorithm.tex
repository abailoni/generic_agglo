% !TEX root = ../agglo_clust_review.tex

\section{Generalized framework for agglomerative clustering of signed graphs} \label{sec:general_framework}
In this section, we first define notation and then introduce one of our main contributions: a signed graph partitioning algorithm (Sec. \ref{sec:algorithm}) that can be seen as a generalization of several existing and new clustering algorithms (Sec. \ref{sec:alg_update_rules}).

\subsection{Notation and graph formalism} \label{sec:notation}

We consider an undirected simple edge-weighted graph $\mathcal{G}(V,E,w^+, w^-)$ with both attractive and repulsive edge attributes. In computer vision applications, the nodes can represent either pixels, superpixels or voxels. We call the set $\Pi$ a \emph{clustering} or \emph{partitioning} with $K$ clusters if $V = \cup_{S\in\Pi} S $, $\,S \cap S' = \emptyset$ for different clusters $S, S'\in \Pi$ and every cluster $S \in \Pi$ induces a connected subgraph of $\mathcal{G}$. We also denote as $S_u$ the cluster associated with node $u$.
The weight function $w^+: E \rightarrow \mathbb{R}^+$ associates to every edge a positive scalar attribute $w_e^+\in \mathbb{R}^+$ representing a merge affinity or a similarity measure: the higher this number, the higher the inclination of the two incident vertices to be assigned to the same cluster\footnote{Note that other formalisms for positively weighted graphs associate distances to the edges, thus, the \emph{lower} the edge weight, the higher the attraction between the two linked nodes, contrary to our definition of $w^+$.}. On the other hand, $w^-: E \rightarrow \mathbb{R}^+$ associates to each edge a split tendency $w_e^- \in \mathbb{R}^+$: the higher this weight, the more the incident vertices would like to be in different clusters. 
Graphs of the type $\mathcal{G}(V,E,w^+, w^-)$ are also often defined as \emph{signed graphs} $\mathcal{G}(V,E,\cost)$, featuring positive and negative edge weights $\cost_e\in \mathbb{R}$. Following the theoretical considerations in \cite{lange2018partial}, we define these signed weights as ${\cost_e = w_e^+ - w_e^-}$. Some approaches directly compute $\cost_e$, whereas others compute $w_e^+$ and $w_e^-$ separately.
In this formalism, graphs with purely attractive interactions are a special case of $\mathcal{G}(V,E,\cost)$ with $\cost_e \geq 0, \, \forall e \in E$. \TODO{shorten and add multicut energy def, define HC abbrv.}

\begin{itemize}
\item Given a linkage $\interact{}$, we say that Algorithm \ref{main_alg} is invariant to a $\alpha$ weight-shift, if by changing all edge weights of the graphs by a constant $w_e+\alpha$ the structure of the hierarchical tree  does not change and defines the same function $d_T$.
\item \TODO{Why do we care?} MC does not return nested/hierarchical solutions when shifting weights. Which of these algorithms behave the same, or, somehow are more related to correlation clustering? So, actually, we care more about the shifted-solutions being nested, and not really about the fact that the hierarchy tree built by the algorithm stays the same. Is this somehow equivalent...?
\end{itemize}


\textbf{Inter-cluster interaction } We call two clusters $S_u,S_v$ \emph{adjacent} if there exists at least one edge ${e_{ts}\in E}$ connecting a node $t\in S_u$ to a node $s\in S_v$. Let the interaction $\interact(S_u,S_v)$ between the two clusters be defined as a function $\interact{}:\Pi \times \Pi \rightarrow \mathbb{R}$, \TODO{Remove $\Pi$ from def. Problem of zero interactions} named \emph{linkage criterion}, depending on the weights of \emph{all} edges connecting clusters $S_u$ and $S_v$, i.e. $(S_u \times S_v) \cap E$. 
All the linkage criteria tested in this article are listed and defined in Table \ref{tab:linkage-criteria}.

% \begin{algorithm}[t]
%   \caption{\algname{}: generalized algorithm for signed graph partitioning}
%    \hspace*{\algorithmicindent} \textbf{Input:} Graph $\mathcal{G}(V,E,w^+,w^-)$; linkage criterion $\interact{}$; boolean {\color{blue}\texttt{addCannotLinkConstraints}}  \\
%   \hspace*{\algorithmicindent} \textbf{Output:} Final clustering $\Pi$\\
%   \hspace*{\algorithmicindent} 
%   \begin{algorithmic}[1]
%       \State Initialize clustering $\Pi=\{\{v_1\}, \ldots, \{v_{|V|}\}\}$ with each node in its own cluster
%       \State Initial interactions between nodes given by $\cost_e = w^+_e - w^-_e$
%       \Repeat
%         \State Select pair of clusters $S_u,S_v\in\Pi$ with highest absolute interaction $|\interact{}(S_u,S_v)|$
%         \If{\big[{\color{ForestGreen}\textbf{$\interact{}(S_u,S_v) > 0$}}\big] \textbf{and} \big[$S_u,S_v$ are \textbf{not} constrained\big]}
%           \State Merge cluster $S_u$ with $S_v$: update interactions and cannot-link constraints with all their neighbors
%         \ElsIf{\big[{\color{red}\textbf{$\interact{}(S_u,S_v) \leq 0$}}\big] \textbf{and} {\color{blue}\texttt{addCannotLinkConstraints}}}
%           \State Add CannotLink Constraint between clusters $S_u$ and $S_v$
%         \EndIf
%       \Until{\big[all interactions between clusters are repulsive\big] \textbf{or} \big[all adjacent clusters have cannot-link constraints\big]}
%       \State
%       \Return $\Pi$
%   \end{algorithmic}
%   \label{main_alg}
% \end{algorithm}



\subsection{\algname{}: generalized algorithm for signed graph partitioning} \label{sec:algorithm} 

\TODO{Update description to new pseudocode} In Algorithm \ref{main_alg}, we provide simplified pseudo-code for the proposed \algname{} algorithm. \algname{} implements a bottom-up approach that starts by assigning each node to its own cluster and then iteratively merges pairs of adjacent clusters. The algorithm has two variants. The first one (option \emph{addCannotLinkConstraints} is \texttt{False}) starts by merging clusters with the strongest attractive interaction and stops once the remaining clusters share only mutual repulsive interactions (see iterations on toy graphs in block 4 of Fig.\ \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}}). After each merging iteration, the interaction between the merged cluster and its neighbors is updated according to one of the linkage criteria $\interact(S_u, S_v)$ listed in Table \ref{tab:linkage-criteria}.

In the second variant (option \emph{addCannotLinkConstraints} is \texttt{True}), Algorithm \ref{main_alg} also introduces cannot-link constraints, which represent mutual exclusion relationships between pairs of nodes that cannot be associated with the same cluster in the final clustering. This variant 
selects the pair of clusters with the highest absolute interaction $|\interact(S_u, S_v)|$, so that the most attractive and the most repulsive pairs are analyzed first (see example in Fig.\ \ref{subfig:with_constraints}). If the interaction is repulsive, then the two clusters are constrained and its members can never merge in subsequent steps. If the interaction is attractive, then the clusters are merged, provided that they were not previously constrained. 
The algorithm terminates when all the remaining clusters are constrained.

In Appendix \ref{sec:detailed_impl}, we comment on the algorithm's computational complexity $\mathcal{O}(N^2 \log N)$ and present our implementation given by the edge contraction Algorithm \ref{detailed_alg} based on a \emph{disjoint set data structure} and a \emph{priority queue}.

\begin{algorithm}[t]
\footnotesize
  \begin{flushleft}
  \footnotesize
  \caption{\algname{}}
  % \caption{\algname{}: generalized algorithm for signed graph partitioning}
   \hspace*{\algorithmicindent} \textbf{Input:} Graph $\mathcal{G}(V,E,w^+,w^-)$; linkage criterion $\interact{}$; \\ 
   \hspace*{4.3em}boolean {\color{blue}addCannotLinkConstraints}  \\
  \hspace*{\algorithmicindent} \textbf{Output:} Final clustering $\Pi^*$, rooted binary hierarchical tree $T^*$\\
  \hspace*{\algorithmicindent} 
  \begin{algorithmic}[1]
  \footnotesize
  % \small
      \State Initial clustering: $\Pi=\{\{v_1\}, \ldots, \{v_{|V|}\}\}$
      \State Initialize hierarchical tree $T$ with leaves nodes $V=\{v_1,\ldots,v_{|V|}\}$
      \State Initialize interactions between clusters with $\cost_e = w^+_e - w^-_e$
      \State \emph{// Phase 1: Merge positive interactions (possibly using constraints)}
      \State Push absolute interactions $|w_e|$ to priority queue $PQ$
      \Repeat 
        \State Pop $S_u,S_v\in\Pi$ from $PQ$ with highest interaction $|\interact{}(S_u,S_v)|$
        \If{\big[{\color{green}\textbf{$\interact{}(S_u,S_v) > 0$}}\big] \textbf{and} \big[$S_u,S_v$ \textbf{not} constrained\big]}
          \State Merge clusters $S_u$, $S_v$ and update hierarchical tree $T$
          \State Update interactions \& constraints with neighboring clusters
        \ElsIf{{\color{blue}addCannotLinkConstr} \textbf{and}  \big[{\color{red}\textbf{$\interact{}(S_u,S_v) \leq 0$}}\big]}
          \State Add CannotLink Constraint between $S_u$ and $S_v$
        \EndIf
      \Until{\big[$PQ$ is empty\big]}
      % \State
      % \If{{\color{blue}addCannotLinkConstr}} % \Comment{Step 2: release constraints}
      \State \emph{// Phase 2: Relax constraints \& merge remaining positive interactions}
      \State Push signed interactions $\interact{}(S_u,S_v)$ to PQ, $\forall S_u, S_v \in \Pi$
      \Repeat 
        \State Pop $S_u,S_v\in\Pi$ from $PQ$ with highest interaction $\interact{}(S_u,S_v)$
        \If{\big[{\color{green}\textbf{$\interact{}(S_u,S_v) > 0$}}\big]}
          \State Merge clusters $S_u$, $S_v$ and update hierarchical tree $T$
          \State Update interactions with neighboring clusters
        \EndIf
      \Until{\big[{\color{red}\textbf{$\interact{}(S_u,S_v) \leq 0$}}\big]} 
      \State Save the final clustering $\Pi^* \gets \Pi$ 
      \State \emph{// Phase 3: Merge negative interactions until one single cluster is left}
      \Repeat
        \State Pop $S_u,S_v\in\Pi$ from $PQ$ with highest interaction $\interact{}(S_u,S_v)$
        \State Merge clusters $S_u$, $S_v$ and update hierarchical tree $T$
        \State Update interactions with neighboring clusters
      \Until{\big[Only one cluster is left in $\Pi$\big]} 
      % \EndIf
      \State
      \Return $\Pi^*$, $T^*\gets T$
  \end{algorithmic}
    \label{main_alg}
  \end{flushleft}

\end{algorithm}


\paragraph{Hierarchical trees and ultrametrics} In HC literature,  a \emph{dendrogram} $T$ is a rooted binary tree\footnote{In general, one could look at trees that are not binary. However, the algorithms discussed in this paper always generate binary hierarchical trees, so nothing would be gained by this generalization.} representing the merging order of an agglomerative algorithm, such that the leaves of this tree are in one-to-one correspondence with $V$. 
Let $T_{\mathrm{R}},T_{\mathrm{L}}\subset T$ denote the subtrees rooted at the two children of the root node in $T$.
For any two leaves $u,v \in V$, let $T[u \vee v]$ be the subtree rooted at the least common ancestor of $u$ and $v$ (furthest from the root), and let \texttt{leaves}$(T[u \vee v])\subseteq V$ be the set of leaves of this subtree. 
% \TODO{Here we talk about the algorithm already, so we could move it to next section and the flow could be better. But we need a tree in the alg. So we better do this later}
Algorithm \ref{main_alg} returns a binary tree denoted by $T^*$.
For each pair of distinct leaves $u,v$, we can then assign a \emph{depth} \TODO{better name?} to their least common ancestor node in $T^*$ defined by the interaction between clusters $S_u$ and $S_v$, when $u$ and $v$ were merged: \TODO{See trees on toy graphs in Fig. 1} 
% Then, given a binary tree $T$ and a linkage criterion $\interact$, we can associate a \emph{signed similarity} function $\treeHeight$ to each pair of distinct original nodes $u\neq v$, with $u, v \in V$:
\begin{equation}
\treeHeight(u,v) \equiv \interact{} \big( \text{\texttt{leaves}}(T^*_{\mathrm{R}}[u \vee v]), \text{\texttt{leaves}}(T^*_{\mathrm{L}}[u \vee v]) \big)
\end{equation}

The connection between hierarchical trees and ultrametrics is well known\footnote{A metric space $(X,d)$ is an \emph{ultrametric} if for every $x,y,z \in X$, $d(x,y)\leq \max \{d(x,z), d(y,z)\}$.}. 
We now want to use the \emph{depth-measure} $\treeHeight{}$ to define an ultrametric on the graph.  
Normally, ultrametrics are associated to strictly positive \emph{similarity} or \emph{dissimilarity} measures on a graph. Thus, we first need to map $\treeHeight{}$ to positive values:
\begin{align}
d_{T^*}(u,v)\equiv &\begin{cases}
0 & \text{if}\,\, u=v\\
M-\treeHeight(u,v) & \text{if}\,\, u\neq v
\end{cases}\quad \forall u,v\in V\\
\mathrm{where}& \quad  M \equiv \max_{u',v'\in V,\,u'\neq v'}\treeHeight(u',v').
\end{align}
By definition, we have that  $d_{T^*}: V \times V \rightarrow \mathbb{R}^{+}$, $d_{T^*}(u,v)=d_{T^*}(v,u)$, and $d_{T^*}(u,u)= 0$. Thus, to prove that $(V, d_{T^*})$ is an ultrametric, we only need to prove that
\begin{equation}
\interact{}_{T^*}(u,v) \geq \min \{\interact{}_{T^*}(u,t), \interact{}_{T^*}(v,t)\}
\end{equation}
 for every distinct $u,v,t\in V$. In other words, given two leaves nodes $u,v\in V$, the depth $\interact{}_{T^*}(u,v)$ associated to their least common ancestor $i\in T^*$ should be both lower than the depth of any $i$-descendant node in $T^*$ and higher than any $i$-ancestor node in $T^*$:
 % that have the most positive interaction   two clusters merged by the algorithm will always have an interaction that is more negative as compared to all clusters already merged and more positive than all clusters that will be merged at later iterations of the algorithm.
\begin{equation}
\interact{}_{T^*}(u,v) \geq \interact{}_{T^*}(u,t) \Leftrightarrow T^*[u \vee t] \subseteq T^*[u \vee v] 
\end{equation}
 This happens only if, at every iteration, Algorithm \ref{main_alg} merges pairs of clusters with lower and lower interactions, which is true for only certain choices of linkage criteria. %In the next section \ref{sec:alg_update_rules}, we will show that this happens only for certain linkages and only when constraints are not enforced





\subsection{\algname{} with different linkage criteria: new and existing algorithms} \label{sec:alg_update_rules}

\TODO{Specify greediness wrt multicut energy, ultrametric properties, and shift-invariance properties} Our main contribution is the generalized algorithm for signed graph partitioning, GASP, that encompasses several known and new agglomerative algorithms on display in Table \ref{tab:linkage-criteria}.
In our framework, individual algorithms are differentiated by the linkage criterion employed. We review them in the following paragraphs.

In the special case of an unsigned graph with only positive interactions, i.e. $w_e^-=0$ and $\cost_e \geq 0$ $\forall e\in E$, 
 the algorithm performs a standard agglomerative hierarchical clustering by returning only a single cluster and a hierarchy of clusters defined by the order in which the clusters are merged (see Table \ref{tab:linkage-criteria}, unsigned graphs).

Given a graph with both attractive and repulsive cues, an edge contraction algorithm with a sum update rule was pioneered in \cite{levinkov2017comparative,keuper2015efficient} (Table \ref{tab:linkage-criteria}, \emph{Sum} linkage). The authors present both a version with cannot-link constraints and one without, and then compare them with other greedy local-search algorithms approximating the multicut optimization problem.
The Mutex Watershed \cite{wolf2018mutex} is another signed graph partitioning algorithm that introduces dynamical cannot-link constraints. In Proposition \ref{prop:equiv_MWS} (see Appendix \ref{sec:appendix_abs_max}) we prove that, surprisingly, it can also be seen as an efficient implementation of \algname{} with \emph{Absolute maximum} linkage (def. in Table \ref{tab:linkage-criteria}). Moreover, in Proposition \ref{prop:abs_max_cannot_link_property} we also prove that \algname{} with \emph{Abs Max} linkage returns the same clustering with or without enforcing cannot-link constraints.
On the other hand, to our knowledge, \emph{Average}, \emph{Max} or \emph{Min} linkage criteria have never been used for signed graph agglomerative algorithms or been combined with cannot-link constraints.

Apart from the linkage criteria defined in Table \ref{tab:linkage-criteria}, additional ones were proposed in the literature:
\cite{nunez2013machine} for example uses a learned approach where a random forest classifier updates the cluster interactions depending on predefined edge and node features; other approaches introduce a weight regularization depending on the size of the clusters \cite{felzenszwalb2004efficient,kardoostsolving}, whereas 
\cite{funke2018large} uses a \emph{quantile} linkage criterion by populating a histogram for each inter-cluster interaction. In our experiments, we decided to focus on the linkage criteria listed in Table \ref{tab:linkage-criteria}, since they represent the most common options.

% \begin{figure}[t]
% \centering
%         \begin{subfigure}[t]{0.46 \textwidth}
%         \centering
%         \includegraphics[width=\textwidth]{figs/example_no_constr.pdf}
%         \caption{No constraints}\label{subfig:no_constraints}
%     \end{subfigure} \hfill \vspace{8pt}
%     \begin{subfigure}[t]{0.46 \textwidth}
%         \centering
%         \includegraphics[width=\textwidth]{figs/example_with_constr.pdf}
%         \caption{With cannot-link constraints}\label{subfig:with_constraints}
%     \end{subfigure}
% \caption{Some iterations of the generalized algorithm (using \emph{Sum} linkage criteria) with and without adding cannot-link constraints. The graph has both attractive (green) and repulsive (red) edges and cannot-link constraints are shown with triple violet bars on the edges. The edge selected at each iteration is highlighted in yellow. We note that when constraints are enforced, the final clustering is given by two clusters instead of only one.}
% \label{fig:algorithm_with_without_CLC}
% \end{figure}


% \begin{table*}[t]
%     % \centering
%     \scriptsize
%     \begin{subtable}[t!]{\textwidth}\centering
%         \begin{tabular}{R{5em}  l | M{10em} | M{8em}  M{8em}}
%             \multicolumn{2}{c|}{\multirow{2}{*}[-0.5em]{\thead{\textbf{\algname{} linkage criteria}\\ $\,\,\interact(S_u ,S_v)$}}}  & \multirow{2}{*}[-0.5em]{\thead{\textbf{Unsigned} \\\textbf{Graphs}}} & \multicolumn{2}{c}{\thead{\textbf{Signed Graphs}}}  \\        
%             \multicolumn{2}{c|}{} &  &  \multicolumn{1}{c}{\thead{No \\Constraints}} & \thead{With\\ Constraints} \\        
      
%             \midrule
%              Sum: & $\displaystyle \sum_{e\in E_{uv}} \cost_e$ & \thead{Sum Linkage\\Hier. Aggl. Clust.} & \thead{GAEC \cite{keuper2015efficient}} & \thead{Greedy\\Fixation \cite{levinkov2017comparative}} \\ 
            
%              \makecell[r]{Abs. Max:} & 
%             $\displaystyle \cost_e$ with $\displaystyle e = \argmax_{t\in E_{uv}} |\cost_t|$
%                & \thead{Single Linkage\\Hier. Aggl. Clust.} & \thead{Mutex\\Watershed \cite{wolf2018mutex}} & \thead{Mutex\\Watershed \cite{wolf2018mutex}} \\
%              \makecell[r]{Average:} & $\displaystyle \sum_{e\in E_{uv}} \cost_e \bigg/ \big|E_{uv}\big|  $ & \thead{ Average Linkage\\ Hier. Aggl. Clust.} & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}\\ 

%             Max: & $\displaystyle \max_{e\in E_{uv}} \cost_e$ & \thead{Single Linkage\\Hier. Aggl. Clust.} & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}\\ 

%             Min:& $\displaystyle \min_{e\in E_{uv}} \cost_e$ & \thead{Complete Linkage\\ Hier. Aggl. Clust.}  & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}
%         \end{tabular}
%     \end{subtable} 
%     \vspace{1em}
%     \caption{Existing and new clustering algorithms that can be reformulated as special cases of the proposed generalized algorithm for signed graph partitioning, \algname{}, given a linkage criterion, a type of graph (signed or unsigned) and the optional use of cannot-link constraints. The set $E_{uv}$ is defined as the set of all edges connecting cluster $S_u$ to cluster $S_v$, i.e. $E_{uv}=(S_u \times S_{v \neq u}) \cap E$.}
%     \label{tab:linkage-criteria}
% \end{table*}

\begin{table*}[t]
    \centering
    \footnotesize
    \begin{subtable}[t!]{\textwidth}\centering
        \begin{tabular}{c | c  c  c  c  c}
        \multirow{2}{*}[-0.5em]{\thead{\textbf{\algname{} linkage criteria} \\ $\,\,\interact(S_u ,S_v)$}}  & Sum & Absolute Maximum & Average & Maximum & Minimum \\
 & $\displaystyle \sum_{e\in E_{uv}} \cost_e$  & $\displaystyle \cost_e$ with $\displaystyle e = \argmax_{t\in E_{uv}} |\cost_t|$ & $\displaystyle \sum_{e\in E_{uv}} \cost_e \bigg/ \big|E_{uv}\big| $ &  $\displaystyle \max_{e\in E_{uv}} \cost_e$ & $\displaystyle \min_{e\in E_{uv}} \cost_e$ \\ \midrule

            \thead{\textbf{Unsigned Graphs}} & \thead{HC-Sum-Link} &\thead{HC-Single-Link\\$(\dagger,\ddagger)$} &\thead{HC-Avg-Link\\$(\dagger,\ddagger)$} &\thead{HC-Single-Link\\$(\dagger,\ddagger)$} &\thead{HC-Complete-Link\\$(\dagger,\ddagger)$} \\
            \thead{\textbf{Signed Graphs} \\\textbf{Without Constraints}} & \thead{GAEC \cite{keuper2015efficient}} & \thead{Mutex Watershed \cite{wolf2018mutex}\\$(\dagger)$}& \thead{HC-Avg-Link\\$(\dagger,\ddagger)$} &\thead{HC-Single-Link\\$(\dagger,\ddagger)$} &\thead{HC-Complete-Link\\$(\dagger,\ddagger)$} \\
            \thead{\textbf{Signed Graphs} \\\textbf{With Constraints}} & \thead{Constr-Sum-Link\\(\textbf{NEW})} % \thead{Greedy Fixation \cite{levinkov2017comparative}} 
            & \thead{Mutex Watershed \cite{wolf2018mutex}\\$(\dagger)$}& \thead{Constr-Avg-Link\\(\textbf{NEW})} &  \thead{Constr-Single-Link\\(\textbf{NEW})} &  \thead{Constr-Complete-Link\\(\textbf{NEW})} \\
            % \multicolumn{2}{c|}{\multirow{2}{*}[-0.5em]{\thead{\textbf{\algname{} linkage criteria} $\,\,\interact(S_u ,S_v)$}}}  & \multirow{2}{*}[-0.5em]{\thead{\textbf{Unsigned Graphs}}} & \multicolumn{2}{c}{\thead{\textbf{Signed Graphs}}}  \\        
            % \multicolumn{2}{c|}{} &  &  \multicolumn{1}{c}{\thead{No Constraints}} & \thead{With Constraints} \\ \midrule
             

            %  Sum: & $\displaystyle \sum_{e\in E_{uv}} \cost_e$ & \thead{Sum Linkage\\Hier. Aggl. Clust.} & \thead{GAEC \cite{keuper2015efficient}} & \thead{Greedy\\Fixation \cite{levinkov2017comparative}} \\ 
            
             


            %  \makecell[r]{Abs. Max:} & 
            % $\displaystyle \cost_e$ with $\displaystyle e = \argmax_{t\in E_{uv}} |\cost_t|$
            %    & \thead{Single Linkage\\Hier. Aggl. Clust.} & \thead{Mutex\\Watershed \cite{wolf2018mutex}} & \thead{Mutex\\Watershed \cite{wolf2018mutex}} \\
             


            %  \makecell[r]{Average:} & $\displaystyle \sum_{e\in E_{uv}} \cost_e \bigg/ \big|E_{uv}\big|  $ & \thead{ Average Linkage\\ Hier. Aggl. Clust.} & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}\\ 

            % Max: & $\displaystyle \max_{e\in E_{uv}} \cost_e$ & \thead{Single Linkage\\Hier. Aggl. Clust.} & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}\\ 

            % Min:& $\displaystyle \min_{e\in E_{uv}} \cost_e$ & \thead{Complete Linkage\\ Hier. Aggl. Clust.}  & \thead{\textbf{NEW}} & \thead{\textbf{NEW}}



            
        \end{tabular}
    \end{subtable} 
    \caption{Existing and new clustering algorithms that can be reformulated as special cases of the proposed generalized algorithm for signed graph partitioning, \algname{}, given a linkage criterion, a type of graph (signed or unsigned) and the optional use of cannot-link constraints. The set $E_{uv}$ is defined as the set of all edges connecting cluster $S_u$ to cluster $S_v$, i.e. $E_{uv}=(S_u \times S_{v \neq u}) \cap E$. \TODO{$\dagger$ if the linkage defines ultrametric and $\ddagger$ if it defines a weight-shift invariant algorithm} } 
    \label{tab:linkage-criteria}
\end{table*}

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{./figs/comparison_new.pdf} % left bottom right top
\caption{Failure cases of \algname{} with different linkage criteria highlighted on some difficult parts of the CREMI Challenge data. Only the \emph{wrongly} segmented regions are highlighted in different warm colors. Note that the data is 3D, hence the same color could be assigned to parts of segments that appear disconnected in 2D.  Red arrows point to wrongly split regions. Yellow arrows point out merge errors. The \emph{Average} linkage without cannot-link constraints returned the best segmentation.
\label{fig:cremi_comparison}}
\end{figure*}
