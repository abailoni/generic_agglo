% !TEX root = ../agglo_clust_review.tex

\begin{minipage}[t]{\textwidth}
        \centering
        \begin{minipage}[t]{0.49\textwidth}
\centering
        \includegraphics[width=\textwidth,trim=0.1in 0.4in 0.2in 0.2in,clip]{./figs/edge_contraction.png} % left bottom right top
\captionof{figure}{{\small 
Example of edge contraction of $e_{uv}$. The first row represents the original graph $\mathcal{G}$ and the clustering $\Pi$ (purple lines), where green edges are not on the cut. Red bars indicate cannot-link constraints, whereas the contracted graph $\tilde{\mathcal{G}}_\Pi$ is shown in the second row. In step (ii), edge $e_{uv}$ is contracted and node $v$ deleted from $\tilde{\mathcal{G}}_\Pi$. In (iii), the two double edges $e_{ut}$ and $e_{vt}$ resulting from the contraction are replaced by a single constrained edge with updated interaction $f(\tilde{\cost}(e_{ut}), \tilde{\cost}(e_{vt}))$, where $f$ is defined in Table \ref{tab:linkage-criteria}.} 
\label{fig:edge_contraction_and_contr_graph} }
    \end{minipage}\hspace{0.01\textwidth}
    \begin{minipage}[t]{0.49\textwidth}
        \centering
\includegraphics[width=0.8\textwidth,trim=0.in 0.in 0.in 0.in,clip]{./figs/cannot-lin-constraints.jpg}
\captionof{figure}{\small 
\UPDATE{Comparison of \algname{}  with (top) and without (bottom) enforcing cannot-link constraints on a toy graph with positive (green) and repulsive (red) interactions. Only contracted graph is represented; every column represent one iteration of the algorithm; the selected edge at each iteration is highlighted in yellow; constrained edges are represented with red bars. We note that the two resulting clusterings are different.}
\label{fig:algorithm_with_without_CLC}}
    \end{minipage}
\end{minipage}


\section{Generalized framework for Signed Graphs Agglomerative Clustering}
In this section we introduce the proposed framework for agglomerative clustering of signed graphs. 
%that represents a simple \UPDATE{generalized} formalization of many agglomerative graph clustering algorithms. \UPDATE{It can be used to describe both unsigned clustering algorithms ingesting positive node similarities and signed clustering algorithms using attractive and repulsive cues.}\\
First, we define the graph notation in Sec. \ref{sec:notation}, then we introduce the generalized algorithm in Sec. \ref{sec:algorithm} and finally we show \UPDATE{how it represents a generalized version of several existing and new graph clustering algorithms (Sec. \ref{sec:alg_update_rules}).}

\subsection{Notation and graph formalism} \label{sec:notation}

Given a simple graph $\mathcal{G}(V,E)$, we call the set $\Pi$ a \emph{clustering} with $K$ clusters if $V = \cup_{i=1}^K S_i $, $S_i \cap S_j = \emptyset$ for every $i\neq j$ and every $S \in \Pi$ induces a connected subgraph of $\mathcal{G}$. In the following we denote the cluster associated with node $u$ as $S_u$.
% \begin{equation}
% S_u \equiv S \in \Pi \,\, \text{s.t.} \,\, u \in S
% \end{equation}

In this work, we consider the problem of clustering a weighted graph $\mathcal{G}(V,E,w^+, w^-)$ with both attractive and repulsive edge attributes. The weight function $w^+: E \rightarrow \mathbb{R}^+$ associates a positive scalar attribute $w_e^+\in \mathbb{R}^+$ to each edge $e \in E$ representing a merge affinity or a similarity measure: the higher this number, the higher the inclination of the two incident vertices to be assigned to the same cluster\footnote{Note that several formalisms defining positively weighted graphs associate to each edge a positive scalar that represents a metric or distance on the graph. In these formalisms, the \emph{lower} the edge weight, the higher the attraction between the two linked nodes, contrary to our definition of $w^+: E \rightarrow \mathbb{R}^+$.}. On the other hand, $w^-: E \rightarrow \mathbb{R}^+$ associates a split tendency $w_e^- \in \mathbb{R}^+$ to each edge: the higher this weight, the greater the desire of the incident vertices to be in different clusters. 
Often, graphs $\mathcal{G}(V,E,w^+, w^-)$ with both attractive and repulsive edge attributes are also defined as $\mathcal{G}(V,E,\cost)$, where $\cost: E \rightarrow \mathbb{R}$ represents a \emph{signed interaction} that combines both attraction and repulsion into one signed scalar number: % space: make equation in line
\begin{equation}
\cost_e = w_e^+ - w_e^- \in \mathbb{R}, \quad \quad \forall e \in E
\end{equation}
Graphs that have only positive weights can be clearly seen as a special case of the previously defined graph $\mathcal{G}(V,E,w^+,w^-)$, when $w^-_e=0$ and $\cost_e \geq 0$ for every $e \in E$.

\paragraph{Inter-cluster interaction}\label{par:linkage_criterion_def} We call two clusters $S_1,S_2$ \emph{adjacent} if there exists at least one edge ${e_{uv}\in E}$ connecting a node $u\in S_1$ to a node $v\in S_2$. In agglomerative HC, the interaction $\interact_{S_1,S_2}$ between two clusters $S_1, S_2$ is usually defined as a function, named \emph{linkage criterion}, depending on the weights of all edges connecting clusters $S_1$ and $S_2$. For example, for a \emph{maximum} linkage criterion statistic (single-linkage), the inter-cluster interaction is given by:
\begin{equation}\label{eq:max_linkage}
\interact_{S_1,S_2} = \, \max_{e\in U} \cost(e), \qquad \text{where}\quad U = \{ e_{uv} \in E | u \in S_1, \, v \in S_2 \}.
\end{equation}
Other common choices are \emph{minimum} (complete linkage) or \emph{average} (average linkage). %and \emph{sum}.
% \begin{equation}
%  \text{$S_1, S_2 \in \Pi$ are \emph{adjacent}} \quad \Longleftrightarrow  \quad  \mathcal{B}(S_1,S_2) \equiv \{ e_{uv} \in E | u \in S_1, \, v \in S_2 \} \neq \emptyset
% \end{equation}
% where we defined the set of edges connecting two adjacent clusters as \UPDATE{\emph{boundary}} \UPDATE{$\mathscr{W}(S_1,S_2) , \mathcal{G}'_{\mathcal{G},\Pi}(V',E')$}.  in the boundary $\mathcal{B}(S_1,S_2)$. Some examples of linkage criterion statistics are \emph{maximum} (single-linkage), \emph{minimum} (complete-linkage) and average (average-linkage).

\paragraph{Multicut and correlation clustering} For any clustering $\Pi$ of $\mathcal{G}$, we define as $E^0_\Pi$ the set of edges linking nodes in the same cluster, and as $E_\Pi^1$ the complementary set of edges whose linked nodes belong to distinct clusters:
\begin{equation}
E_\Pi^0 \equiv \{ e_{uv} \in E \,|\, \exists S \in \Pi : u \in S \, \text{and} \, v \in S \}, \qquad E^1_\Pi \equiv E \setminus E^0_\Pi.
\end{equation}
% \begin{align}
% E_\Pi^0 &= \{ e_{uv} \in E \,|\, \exists S \in \Pi : u \in S \, \text{and} \, v \in S \}, \\
% E^1_\Pi &= E \setminus E^0_\Pi.
% \end{align}
The set of edges $E_\Pi^1$ is known as the \emph{multicut} of $\mathcal{G}$ w.r.t. clustering $\Pi$. The instance of the NP-hard \emph{weighted correlation clustering} or \emph{minimum cost multicut problem} w.r.t. $\mathcal{G}(V,E,w^+, w^-)$ \cite{kappes2011globally,chopra1991multiway,andres2015lifting} is the task of finding a clustering that optimally balance the attraction and repulsion in the graph and is given by the following optimization problem/binary integer program:
\begin{equation}
% \min_\Pi \texttt{MC}(\Pi) \equiv
 \min_\Pi \sum_{e\in E} \cost_e x_e^\Pi,  \qquad \text{where} \quad x^\Pi_e = 
 \begin{cases} 
 1 & \text{if } e\in E^1_\Pi \\
 0 & \text{otherwise}.
 \end{cases}
\end{equation}
In the next chapters we will use this objective as a way to measure how much a clustering is balanced.

\begin{algorithm}[t]
  \caption{Generalized Algorithm for Signed Graphs Agglomerative Clustering}
   \hspace*{\algorithmicindent} \textbf{Inputs:} Graph $\mathcal{G}(V,E,w^+,w^-)$ with $N$ nodes; boolean variable {\color{blue}\texttt{addCannotLink}}  \\
  \hspace*{\algorithmicindent} \textbf{Outputs:} Final clustering $\Pi$\\
  \hspace*{\algorithmicindent} 
  \begin{algorithmic}[1]
    % \Procedure{SignedGraphEdgeContr}{{\color{blue}bool \emph{addConstraints}}}
      % \State $\mathcal{G}'\gets \mathcal{G}(V,E^+ \cup E^-)$ \Comment{Initialize the contracted graph}
      \State Initialize clustering $\Pi=\{\{v_1\}, \ldots, \{v_N\}\}$ and contracted graph $\tilde{\mathcal{G}}_\Pi \gets \mathcal{G}$
      \State Initialize \texttt{canBeMerged}$[e] \gets$ \texttt{True} $\,\,\, \forall e\in E$
      \State Sort edges in priority queue (PQ) in descending order of priority $|\cost_e|=|w^+_e - w^-_e|$ 
      \State
      \While{PQ is \textbf{not} empty}
        \State Pop edge $e_{uv}$ in $\tilde{\mathcal{G}}_\Pi$ with highest absolute interaction $|\tilde{\cost}|$
        \If{({\color{ForestGreen}\textbf{$\tilde{\cost} > 0$}}) \textbf{and} \texttt{canBeMerged}$[e_{uv}]$}
          % \State PQ, $\,E_\dagger,\,\, E' \gets$ \textsc{deleteDoubleEdges}($u,v$)
        %   \State Update costs of double edges;
        %   \State Propagate constrained flags of double edges;
          \State Contract $e_{uv}$ in $\tilde{\mathcal{G}}_\Pi$ and merge the two clusters $S_u,S_v \in \Pi$
          \For{every new pair of double edges $(e_1,e_2)$ in $\tilde{\mathcal{G}}_\Pi$}
            % \State Get costs $\cost_1, \cost_2$ of $e_1,e_2$
            \State Delete $e_2$ from $\tilde{\mathcal{G}}_\Pi$ and update priority of $e_1$ with rule $f(\tilde{\cost}_{e_1},\tilde{\cost}_{e_2})$ defined in Tab. \ref{tab:linkage-criteria} 
            % \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} update priority of $e_1$
            % \State Delete $e_2$ from $\mathcal{G}'$
          \EndFor
          % \State  Replace double edges in $\mathcal{G}'$ with single edges
          % \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} and update priorities
        \EndIf
        % \State
        \If{({\color{red}\textbf{$\tilde{\cost} \leq 0$}}) \textbf{and} {\color{blue}\texttt{addCannotLink}}}
          % \State Flag $e_{uv}$ as MustNotLink
          \State \texttt{canBeMerged}$[e_{uv}] \gets$ \texttt{False}
        \EndIf
      \EndWhile
      % \For{$e  \in E$ in descending order of absolute costs $|W(e)|$}
      %   \If{({\color{ForestGreen}\textbf{$W(e) > 0$}}) \textbf{AND} (edge is not constrained)}
      %     \State Contract edge $e$ in the graph $\mathcal{G}'$;
      %     \State Update costs of double edges;
      %     \State Propagate constrained flags of double edges;
      %     % \For{every new double edge}
      %     %   \State Delete double edges
      %     %   \State Insert new one with updated cost
      %     % \EndFor
      %   \EndIf
      %   \If{({\color{red}\textbf{$W(e) \leq 0$}}) \textbf{AND} ({\color{blue}\emph{addConstraints}})}
      %     \State Flag edge $e$ as constrained
      %   \EndIf
      % \EndFor
      % \State
      \State
      \Return $\Pi$
      % \State


    % \EndProcedure

  \end{algorithmic}
  \label{main_alg}
\end{algorithm}


\subsection{Generalized Algorithm for Signed Graphs Agglomerative Clustering} \label{sec:algorithm}

We now present our main contribution: a Generalized Algorithm for Signed Graphs Agglomerative Clustering (\algname) that can describe in a simple form several graph partitioning algorithms previously introduced in the literature and highlights the existence of new ones.

The proposed generalized clustering uses a bottom-up approach starting with each node assigned to its own cluster and iteratively merging pairs of adjacent clusters. Intuitively, the algorithm starts by merging clusters with the strongest attractive interaction, corresponding to the highest positive weights in the graph, and it stops when the remaining clusters share only mutual repulsive interactions (see Fig. \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}b} and \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}c}). 

A second variant of the proposed algorithm also introduces \emph{cannot-link constraints}, representing mutual exclusion relationships between pairs of nodes that cannot be associated with the same cluster in the final clustering. This variant (Algorithm \ref{main_alg} with \texttt{addCannotLink=True}) stops when all the remaining clusters have been previously constrained.
% The algorithm that we will present in the next section iteratively performs a sequence of so-called \emph{edge contractions} on the original graph $\mathcal{G}(V,E,w^+, w^-)$.
% The graph clustering algorithm we will present in Sec. \ref{sec:algorithm} is a bottom-up approach starting with each node assigned to its own cluster and iteratively merging clusters. During the agglomeration, the current clustering $\Pi$ is represented by a \emph{contracted graph} $\mathcal{G'}(\mathcal{G}, \Pi)$, such that each of its nodes represents a cluster $S \in \Pi$ and \emph{adjacent} clusters are linked by an edge. 

\paragraph{Update rules} During the agglomerative process, the interaction between adjacent clusters has to be properly updated and recomputed.  % given by the linkage criterion defined in Sec. \ref{sec:notation} and
An efficient way of implementing these updates can be achieved by representing the agglomeration as a sequence of \emph{edge contractions} in the graph (Fig. \ref{fig:edge_contraction_and_contr_graph}). Given a graph $\mathcal{G}(V,E,\cost)$ and a clustering $\Pi$, we define the associated \emph{contracted graph} $\tilde{\mathcal{G}}_\Pi(\tilde{V}, \tilde{E}, \tilde{\cost})$, such that $\tilde{V} \subseteq V$ and each node $u\in \tilde{V}$ represents the cluster $S_u \in \Pi$, edges in $\tilde{E}$ represent adjacency-relationships between clusters and the signed edge weights $\tilde{\cost}$ are given by inter-cluster interactions, i.e. $\tilde{\cost}(e_{uv})=\interact_{S_u,S_v}$. 
For the linkage criteria tested in this work, when two clusters $S_u$ and $S_v$ are merged, the interactions between the new cluster $S_u \cup S_v$ and each of its neighbors depend only on the previous interactions involving $S_u$ and $S_v$. Thus, we can easily recompute these interactions by using a simple \emph{update rule} $f$ that does not involve any loop over the edges of the original graph $\mathcal{G}$. As an example, given the single-linkage criterion defined in Eq. \ref{eq:max_linkage}, the interaction between $S_u \cup S_v$ and one of its neighbors $S_t$ is simply given by:
\begin{equation}
  \interact_{S_u \cup S_v,S_t} = f( \interact_{S_u,S_t}, \interact_{S_v,S_t}) = f(\tilde{\cost}(e_{ut}), \tilde{\cost}(e_{vt})) = \max \{ \tilde{\cost}(e_{ut}), \tilde{\cost}(e_{vt}) \}
\end{equation}
All the update rules tested in this article are listed in Table \ref{tab:linkage-criteria}.
% \UPDATE{Every time a pair of clusters is merged, the contracted graph is updated by performing an edge contraction and merging the associated nodes. The only interactions that then need to be updated are those between nodes that after the edge contraction happen to be connected by double edges (see Fig. \ref{fig:edge_contraction_and_contr_graph}, step b). For basic linkage criteria, e.g. \emph{max} or \emph{min}, the new interaction can be formulated in terms of an \emph{update rule} $f$ depending only on the these updates can be computed with an update rule $f$ that depends only on the interactions at the previous step }
% As a result, the merged node could be linked to some of its neighbors by double edges . , representing the fact that their interaction should be updated. This update can be easily achieved by using an \emph{update rule} depending only on the weights of the double edges. 
% \TODO{such a mess...} ...without the need of running a loop over the edges of the original graph.
% \UPDATE{In this way we do not need to recompute the interaction by using the linkage criterion over all the edges of the original graph, that would be computationally expensive.}

\paragraph{The edge contraction algorithm} The proposed generalized Algorithm \ref{main_alg} then proceeds as follows, similarly to the one proposed in \cite{levinkov2017comparative}. It starts with each node assigned to its own cluster and sorts all edges $e\in E$ in a priority queue (PQ) by their absolute weight $|\cost_e|=|w_e^+ - w_e^-|$ in descending order, so that the most attractive and the most repulsive interactions are processed first. It then iteratively pops one edge $e_{uv}$ from PQ and, depending on the priority $\tilde{\cost}$, does the following: in case of attractive interaction $\tilde{\cost}>0$, provided that $e_{uv}$ was not flagged as a cannot-link constraint, then merge the connected clusters, perform an edge contraction of $e_{uv}$ in $\tilde{\mathcal{G}}_\Pi$ and update the priorities of new double edges as explained in Fig. \ref{fig:edge_contraction_and_contr_graph}. 
% For every new pair of double edges in $\tilde{\mathcal{G}}_\Pi$, update their priorities according to one of the update rules listed in Table \ref{tab:linkage-criteria} together with their cannot-link relationships. 
If, on the other hand, the interaction is repulsive ($\tilde{\cost}\leq 0$) and the option \texttt{addCannotLink} of Alg. \ref{main_alg} is \texttt{True}, then the edge $e_{uv}$ is flagged as cannot-link constraint.
In the Supplementary material we provide a more detailed description of the algorithm and we also comment on its computational complexity (Sec. \ref{sec:complexity}).

 %\TODO{use def of merging process of contracted graph to define merging tree?}.

% \item Comment about must-not-link relations: they give high priority to the most confident repulsive edges {}


% Given a clustering $\Pi$ and a graph $\mathcal{G}(V,E,W)$, the interaction between two clusters $S_1, S_2 \in \Pi$ is usually defined in terms of a \emph{linkage criterion}, i.e. a function of all the edge weights connecting the two clusters:
% \begin{equation} 
% \begin{gathered}
% \mathcal{L}(S_1,S_2) = \mathcal{L}(\mathcal{W})\quad \\
%    \text{where} \quad \mathcal{W} = \{ W(e_{uv})| u\in S_1, v\in S_2 \}.
% \end{gathered}
% \end{equation}


\begin{table*}
    \centering
    \begin{subtable}[t!]{\textwidth}\centering
        \begin{tabular}{r l || c | c | c}
            % \toprule\toprule
             & &  \multirow{3}{*}{\textbf{Unsigned graphs}}  & \multicolumn{2}{c}{\textbf{Signed graphs}}  \\        
            % \cmidrule(l{.15em}){4-5}
            % \cline{4-5}
            & & &  \multicolumn{2}{c}{\thead{Add Cannot-Link Constraints:}} \\        
           
            & & &  \thead{\textsc{No}} & \thead{\textsc{Yes}} \\        
            % \cmidrule[0.3em]{3-5}
            % \midrule[0.15em]
            \midrule\midrule
            Sum: & \thead[l]{$f(\tilde{\cost}_1,\tilde{\cost}_2) = \tilde{\cost}_1+\tilde{\cost}_2$} & \thead{Sum Linkage\\Hierarchical Aggl.\\Clustering} & \thead{Greedy Additive \\ Edge Contraction \\\cite{levinkov2017comparative}} & \thead{Greedy \\Fixation \\\cite{levinkov2017comparative}} \\ \midrule
            
            \makecell[r]{Abs. \\ max:} & \thead[l]{
            $
            f(\tilde{\cost}_1,\tilde{\cost}_2) = \begin{cases} 
            \tilde{\cost}_1 & \text{if}\,\, |\tilde{\cost}_1|>|\tilde{\cost}_2|\\
            \tilde{\cost}_2 & \text{otherwise}
             \end{cases} 
            $}
               & \thead{Single Linkage\\Hierarchical Aggl.\\Clustering \cite{lance1967general}} & \thead{Mutex \\Watershed \\\cite{wolf2018mutex}} & \thead{Mutex \\Watershed \\\cite{wolf2018mutex}} \\ \midrule
            \makecell[r]{Mean:} & \thead[l]{$f(\tilde{\cost}_1,\tilde{\cost}_2) = \mathrm{weightAvg}\{ \tilde{\cost}_1, \tilde{\cost}_2 \} $}                                 & \thead{ Average Linkage\\ Hierarchical Clust. \\(UPGMA) \cite{lance1967general}} & \thead{Average Linkage\\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Max: & \thead[l]{$f(\tilde{\cost}_1,\tilde{\cost}_2) = \max \{ \tilde{\cost}_1, \tilde{\cost}_2 \}  $}                                 & \thead{Single Linkage\\Hierarchical Aggl.\\Clustering \cite{lance1967general}} & \thead{Single Linkage \\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Min:& \thead[l]{$f(\tilde{\cost}_1,\tilde{\cost}_2) = \min \{ \tilde{\cost}_1, \tilde{\cost}_2 \}  $}                                 & \thead{Complete Linkage\\ Hierarchical Aggl.\\Clustering \cite{lance1967general}}  & \thead{Complete Linkage \\Signed Aggl. Clust. \\ (\textbf{NEW})} & \thead{\textbf{NEW}}



            
        \end{tabular}
        % \caption{Linkage criteria}
    \end{subtable} 
    \caption{The table lists the update rules $f$ tested in this article. Depending on the type of graph (signed or unsigned) and the use of cannot-link constraints, existing and new algorithms are obtained.}
    \label{tab:linkage-criteria}
\end{table*}


\subsection{Different update rules: new and existing algorithms} \label{sec:alg_update_rules}
\begin{itemize}
\item In this section we will list some of the algorithms that can be described using the generalized Algorithm \ref{main_alg} presented above \UPDATE{and we will introduce some new ones}.
\item In Table \ref{tab:linkage-criteria} we collected the update rules that we tested and compared in this article. Later we will mention more of them that were proposed in the literature.

\item In the special case of a graph with only positive edge interactions, i.e. $w_e^-=0$ $\forall e\in E$, %$\mathcal{G}(V,E,W:E\rightarrow \mathbb{R}^+)$ 
 the algorithm performs a standard agglomerative hierarchical clustering by returning only one single cluster (see Fig. \hyperref[fig:intro_figure]{\ref*{fig:intro_figure}a}) and a hierarchy of clusters defined by the order in which the clusters were merged. 
 

\item In the special case of unsigned graphs (Table \ref{tab:linkage-criteria} column 1), the UGAC algorithm becomes simply a version of hierarchical clustering with different linkage criteria depending on the chosen update rule. It outputs one single cluster and it also defines a hierarchy of clusters during the merging process that can be associated to \UPDATE{a merging tree/  the hierarchical clustering dendrogram}... \TODO{Problem: sum does not trivially define an ultra-metric-distance...}  
\item In the literature there have been already several methods using cannot-link constraints for agglomerative clustering algorithms \TODO{repetition from related work}: for example, \cite{malmberg2011generalized} used initially fixed mutual exclusion relationships, whereas \cite{levinkov2017comparative} introduced them dynamically in an edge contraction algorithm for signed graphs, named Greedy Fixation (Table \ref{tab:linkage-criteria} row 1, \emph{sum}). At the same time, they also proposed a version of it without cannot link constraints (Greedy Additive Edge Contraction) and they compared both with other greedy and local-search algorithms for solving the multicut/correlation clustering problem.
\item Dynamically introduced cannot-link constraints were also proposed by \cite{wolf2018mutex}, that... \TODO{brief MWS description as efficient implementation of this update rule}. In the Supplementary material we show that the algorithm they present can be seen as a special case of UGACA with absolute maximum update rule (Table \ref{tab:linkage-criteria} row 2 - \emph{absolute maximum}) and that adding or not cannot-link constraints does not change the final clustering.
\item On the other hand, the signed graph versions of UGACA with update rules \emph{arithmetic mean}, \emph{max} and \emph{min} (rows 3 to 5 in Table \ref{tab:linkage-criteria}) are new algorithms that were never mentioned in the literature, \UPDATE{especially those with cannot-link constraints}.
\item In this article, we test and run a comparison of the five types of update rule listed in Table \ref{tab:linkage-criteria} (i.e. \emph{sum}, \emph{absolute max}, \emph{arithmetic mean}, \emph{max} and \emph{min}), since \UPDATE{they they are the most commonly used and the cheapest to compute}. Nevertheless, UGACA can be easily generalized to include even more complex rules. For instance, \cite{nunez2013machine} proposes a learned version of update rule where a neural network updates the edge weights depending on edge and node features; another really common choice is to introduce a weight regularization depending on the size of the linked nodes (\cite{felzenszwalb2004efficient} and \cite{kardoostsolving} (unpublished...??), Thorsten..); 
\cite{funke2018large} on the other hand accumulate statistics for each \UPDATE{boundary between clusters} by keeping a discrete histograms of the edge weights and then computes quantiles from it.

\end{itemize}
\TODO{More details on efficient implementations in appendix?}

% \begin{table*}[t]
%     \centering
%     \begin{subtable}[t!]{0.98\textwidth}\centering
%         \begin{tabular}{c | c }
%             \toprule\toprule
%             \makecell{Algorithm name} & \makecell{Algorithm description and \\linkage criteria}    \\
%             \midrule\midrule

%             Weighted Arithmetic Mean (WPGMA) & \thead{Assign a weighting $\alpha_e \in \mathbb{R}^+$, $\forall e \in E$ \\ \\ Linkage criteria: $w_{\mathrm{new}} = \frac{\alpha_1 w_1 +\alpha_2 w_2}{\alpha_1 + \alpha_2} $}  \\ \midrule
            
%             \makecell{Felzenszwalb Efficient \\Graph-based Image Segmentation \cite{felzenszwalb2004efficient}}  & \thead{Initially all edges have positive weights }  \\ \midrule

%             \makecell{Quantile Agglomeration Clustering (...?)}  & \thead{...}  \\ \midrule

%             \makecell{Graph-based active learning \\of agglomeration (GALA) \cite{nunez2013machine}}  & \thead{Assign set of edge features $\phi^{\mathrm{I}}_e$ and \\node features $\phi^{\mathrm{II}}_u$, $\forall u \in V$, $\forall e \in E$. \\ \\ A classifier $f$ with parameters $\theta$ predicts and updates\\ the cost of an edge: $w_e = f(\phi^{\mathrm{I}}_e, \phi^{\mathrm{II}}_u, \phi^{\mathrm{II}}_v; \theta)$, $\forall e_{uv} \in E$} \\ \midrule

%             % \makecell{$w_{\mathrm{new}}=w_{\tilde{e}}$,$\,
%             % \,$ where $\tilde{e}=\mathrm{arg}\max_{e\in \{e_{1},e_{2}\}} \left|w_e\right|$  }  & \thead{Mutex Watershed \cite{wolf2018mutex}} & \thead{Mutex Watershed \cite{wolf2018mutex}} \\ \midrule

%             % Arithmetic mean: $w_{\mathrm{new}} = (w_1+w_2) / 2 $                                 & \thead{Hierarchical Clustering \\ with Average Linkage (UPGMA)} & \thead{\textbf{NEW}}\\ \midrule

%             % Maximum: $w_{\mathrm{new}} = \max \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Single Linkage} & \thead{\textbf{NEW}}\\ \midrule

%             % Minimum: $w_{\mathrm{new}} = \min \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Complete Linkage} & \thead{\textbf{NEW}}



            
%         \end{tabular}
%         % \caption{Linkage criteria}
%         \label{tab:linkage-criteria}
%     \end{subtable} 
%     \caption{Linkage criteria 2}
% \end{table*}






