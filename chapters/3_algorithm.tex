% !TEX root = ../agglo_clust_review.tex

\begin{figure}
\centering
\includegraphics[width=0.50\textwidth,trim=0.1in 0.4in 0.2in 0.2in,clip]{./figs/edge_contraction.png} % left bottom right top
\caption{\small 
Example of edge contraction: the edge $e_{uv}$ is selected from priority queue; after nodes $u$ and $v$ are merged and $e_{uv}$ is deleted, there are two double edges $e_1$ and $e_2$ left in the graph...  
\label{fig:edge_contraction_and_contr_graph} }
\end{figure}

\section{Unified Graph Agglomerative Clustering}
In this section we introduce a unified agglomerative clustering algorithm that represents a simple generalized formalization of many agglomerative graph clustering algorithms. It can be used to describe both unsigned clustering algorithms ingesting positive cluster similarities and signed clustering algorithms using attractive and repulsive cues.\\
First, we define the graph notation and the concept of cannot-link constraints. Then, we introduce the generalized algorithm and show \UPDATE{how it can be used to introduce several new agglomerative clustering algorithms for graphs with signed weights.}

\subsection{Contracted graph and cannot-link constraints} \label{sec:contr_graph_and_CLC}

\begin{itemize}
\item Define graph formalism and clustering $\Pi$. Make comment about special case of unsigned graph
\item Define multicut and associated energy

\item A cannot-link-constraint defines a mutual exclusion relationship between two nodes in the graph and is used to specify that the these two nodes should not be associated with the same cluster. (the alg. will introduce them dynamically...)
\item Define contracted graph and edge contraction (explain Fig. 2)
\item Given a clustering $\Pi$ and a graph $\mathcal{G}(V,E,W)$, the interaction between two clusters $S_1, S_2 \in \Pi$ is usually defined in terms of a \emph{linkage criterion}, i.e. a function of all the edge weights connecting the two clusters:
\begin{equation} \label{eq:linkage_criterion_def}
\begin{gathered}
\mathcal{L}(S_1,S_2) = \mathcal{L}(\mathcal{W})\quad \\
   \text{where} \quad \mathcal{W} = \{ W(e_{uv})| u\in S_1, v\in S_2 \}.
\end{gathered}
\end{equation}

\end{itemize}


\begin{algorithm}
  \caption{Unified Graph Agglomerative Clustering}
   \hspace*{\algorithmicindent} \textbf{Inputs:} graph $\mathcal{G}(V,E,W)$; bool {\color{blue}\texttt{addCannotLink}}  \\
  \hspace*{\algorithmicindent} \textbf{Outputs:} Final clustering and contracted graph $\mathcal{G}'$\\
  \hspace*{\algorithmicindent} 
  \begin{algorithmic}[1]


    % \Procedure{SignedGraphEdgeContr}{{\color{blue}bool \emph{addConstraints}}}
      % \State $\mathcal{G}'\gets \mathcal{G}(V,E^+ \cup E^-)$ \Comment{Initialize the contracted graph}
      \State Initialize contracted graph $\mathcal{G}'$ from $\mathcal{G}$
      \State Initialize \texttt{canBeMerged}$[e] \gets$ \texttt{True} $\,\,\, \forall e\in E$
      \State Sort edges in priority queue (PQ) in desc. order of $|W_e|$ 
      \State
      \While{PQ is \textbf{not} empty}
        \State Pop edge $e_{uv}$ in $\mathcal{G}'$ with highest priority $|\tilde{w}|$
        \State
        \If{({\color{ForestGreen}\textbf{$\tilde{w} > 0$}}) \textbf{and} \texttt{canBeMerged}$[e_{uv}]$}
          
          % \State PQ, $\,E_\dagger,\,\, E' \gets$ \textsc{deleteDoubleEdges}($u,v$)
          
        %   \State Update costs of double edges;
        %   \State Propagate constrained flags of double edges;
          \State Contract $e_{uv}$ in $\mathcal{G}'$
          \For{every new pair of double edges $(e_1,e_2)$}
            \State Get priorities $\tilde{w}_1, \tilde{w}_2$ of $e_1,e_2$
            \State Use update rule $f(\tilde{w}_1,\tilde{w}_2)$ (see Table 1) to 
            \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} update priority of $e_1$
            \State Delete $e_2$ from $\mathcal{G}'$
          \EndFor
          % \State  Replace double edges in $\mathcal{G}'$ with single edges
          % \Statex \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} and update priorities
        \EndIf
        \State
        \If{({\color{red}\textbf{$\tilde{w} \leq 0$}}) \textbf{and} {\color{blue}\texttt{addCannotLink}}}
          % \State Flag $e_{uv}$ as MustNotLink
          \State \texttt{canBeMerged}$[e_{uv}] \gets$ \texttt{False}
        \EndIf
      \EndWhile


      % \For{$e  \in E$ in descending order of absolute costs $|W(e)|$}
      %   \If{({\color{ForestGreen}\textbf{$W(e) > 0$}}) \textbf{AND} (edge is not constrained)}
      %     \State Contract edge $e$ in the graph $\mathcal{G}'$;
      %     \State Update costs of double edges;
      %     \State Propagate constrained flags of double edges;
      %     % \For{every new double edge}
      %     %   \State Delete double edges
      %     %   \State Insert new one with updated cost
      %     % \EndFor
      %   \EndIf
      %   \If{({\color{red}\textbf{$W(e) \leq 0$}}) \textbf{AND} ({\color{blue}\emph{addConstraints}})}
      %     \State Flag edge $e$ as constrained
      %   \EndIf
      % \EndFor
      \State
      \State
      \Return $\mathcal{G}'$
      % \State


    % \EndProcedure

  \end{algorithmic}
  \label{main_alg}
\end{algorithm}


\subsection{The algorithm}

We now present our first contribution: a unified algorithm for agglomerative graph clustering that can describe in a simple general form many graph partitioning algorithms previously introduced in the literature \UPDATE{and highlights the existence of totally new algorithms}.

We consider a graph $\mathcal{G}(V,E,W)$ with associated signed edge weights, where each node initially represents one cluster.
The proposed graph partitioning algorithm is a general form of agglomerative clustering that outputs a final graph clustering $\Pi$ by progressively merging pairs of neighboring clusters. The algorithm starts by merging clusters with the strongest attractive interaction, corresponding to the highest positive weights in the graph, and it stops when the remaining clusters share only mutual repulsive interactions (see Fig. \ref{fig:general_idea}b and \ref{fig:general_idea}c). 

A second variant of the proposed algorithm also introduces cannot-link constraints between clusters during the agglomeration and stops when all the remaining clusters have been previously constrained (option \texttt{addCannotLink} in Algorithm \ref{main_alg}).


During the agglomerative process, the interaction between neighboring clusters is defined by the linkage criterion defined in Equation \ref{eq:linkage_criterion_def} and has to be properly recomputed. 
One possible efficient way of doing this is to use an edge contraction algorithm like the one presented in Algorithm \ref{main_alg}, which proceeds as follows.

Given an initial clustering $\Pi$ where each node of the original graph $\mathcal{G}$ represents its own cluster, the algorithm starts by initializing a contracted graph $\mathcal{G}'$ (see Definition \ref{def:contr_graph}) that will represent the clustering $\Pi$ at each iteration of the agglomeration. The algorithm then sorts all edges $e\in E$ by their absolute weight $|W(e)|$ in descending order in a priority queue, so that the most attractive and the most repulsive edges are processed first. It iteratively pops one edge $e_{uv}$ from priority queue and, depending on the value of the priority $\tilde{w}$ associated to $e_{uv}$, does the following. If the edge is attractive and $\tilde{w}>0$, then perform an edge contraction of $e_{uv}$ in $\mathcal{G}'$ (see Sec. \ref{sec:contr_graph_and_CLC} and Fig. \ref{fig:edge_contraction_and_contr_graph}), provided that $e_{uv}$ was not previously flagged as a cannot-link constraint; for every new pair of double edges in $\mathcal{G}'$ update \UPDATE{their priorities} according to one of the update rules listed in Table \ref{tab:linkage-criteria} and update cannot-link relationships (see example in Fig. \ref{fig:algorithm_with_without_CLC}b from step 3 to 4). If, on the other hand, the edge $e_{uv}$ is repulsive and $\tilde{w}\leq 0$, then flag it as a cannot-link constraint if and only if the algorithm input-option \texttt{addCannotLink} is true and mutual exclusion relationships should be enforced.

In the Supplementary material we provide a more detailed version of the algorithm implementation (Sec. \ref{sec:detailed_algorithm}) and we also comment on its theoretical complexity (Sec. \ref{sec:complexity}).

 In the special case of an unsigned graph %$\mathcal{G}(V,E,W:E\rightarrow \mathbb{R}^+)$ 
 presenting strictly positive similarities between nodes, the algorithm then returns only one single cluster as an output (see Fig. \ref{fig:intro_figure}a), \UPDATE{together with a merging tree representing the merging order and defining an hierarchy of clusters} \TODO{use def of merging process of contracted graph to define merging tree}.

% \item Comment about must-not-link relations: they give high priority to the most confident repulsive edges {}



\begin{figure}
\centering
\includegraphics[width=0.45\textwidth,trim=0.in 0.in 0.in 0.in,clip]{./figs/cannot-lin-constraints.png}
\caption{\small 
Example of agglomerative clustering on signed graph with and without cannot-link constraints...
\label{fig:algorithm_with_without_CLC}}
\end{figure}

\begin{table*}
    \centering
    \begin{subtable}[t!]{0.98\textwidth}\centering
        \begin{tabular}{r l || c | c | c}
            % \toprule\toprule
             & &  \multirow{3}{*}{\textbf{Unsigned graphs}}  & \multicolumn{2}{c}{\textbf{Signed graphs}}  \\        
            % \cmidrule(l{.15em}){4-5}
            % \cline{4-5}
            & & &  \multicolumn{2}{c}{\thead{Add Cannot-Link-Constraints:}} \\        
           
            & & &  \thead{NO} & \thead{YES} \\        
            % \cmidrule[0.3em]{3-5}
            % \midrule[0.15em]
            \midrule\midrule
            Sum: & $f(\tilde{w}_1,\tilde{w}_2) = \tilde{w}_1+\tilde{w}_2$ & \thead{Sum Linkage\\Hierarchical Clustering} & \thead{Greedy Additive \\ Edge Contraction \cite{levinkov2017comparative}} & \thead{Greedy Fixation \cite{levinkov2017comparative}} \\ \midrule
            
            \makecell[r]{Absolute \\ maximum:} & \makecell[l]{$f(\tilde{w}_1,\tilde{w}_2) =\argmax_{\tilde{w}\in\{\tilde{w}_{1},\tilde{w}_{2}\}} \big|\tilde{w} \big| $}   & \thead{Single Linkage\\Hierarchical Clustering\\ \cite{lance1967general}} & \thead{Mutex Watershed \cite{wolf2018mutex}} & \thead{Mutex Watershed \cite{wolf2018mutex}} \\ \midrule

            \makecell[r]{Arithmetic \\mean:} & $f(\tilde{w}_1,\tilde{w}_2) = \mathrm{weightedAvg}\{ \tilde{w}_1, \tilde{w}_2 \} $                                 & \thead{ Average Linkage\\ Hierarchical Clustering \\(UPGMA) \cite{lance1967general}} & \thead{Signed Agglomerative Clust. \\ with Average Linkage \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Maximum: & $f(\tilde{w}_1,\tilde{w}_2) = \max \{ \tilde{w}_1, \tilde{w}_2 \}  $                                 & \thead{Single Linkage\\Hierarchical Clustering\\ \cite{lance1967general}} & \thead{Signed Agglomerative Clust. \\ with Single Linkage \\ (\textbf{NEW})} & \thead{\textbf{NEW}}\\ \midrule

            Minimum:& $f(\tilde{w}_1,\tilde{w}_2) = \min \{ \tilde{w}_1, \tilde{w}_2 \}  $                                 & \thead{Complete Linkage\\ Hierarchical Clustering \\ \cite{lance1967general}}  & \thead{Signed Agglomerative Clust. \\ with Complete Linkage \\ (\textbf{NEW})} & \thead{\textbf{NEW}}



            
        \end{tabular}
        % \caption{Linkage criteria}
    \end{subtable} 
    \caption{The table lists all the algorithms that can be seen as special cases of the Generic Agglomerative Clustering \ref{main_alg} given a specific update rule $f(e_1,e_2)$ and a type of graph...}
    \label{tab:linkage-criteria}
\end{table*}


\subsection{Update rules and associated algorithms}
\begin{itemize}
\item In this section we will list \UPDATE{ALL} (...) algorithms that can be described using the generalized algorithm we presented and define some new ones
\item In Table 1 we collected the update rules we tested and compared in this article (correspond to the simplest and cheapest ones to compute). Later we will mention more of them
\item First unsigned graphs: the merging tree defined by the algorithm (\textbf{define merge tree somewhere..?}) is equivalent to the hierarchical dendrogram (but careful with the sum...) that we have in HC
\item Then mention CLC and who started using them recently for this type of problem: fixed, then greedyFixation introduced exactly this algorithm as a greedy approx of MC, together with Greedy Additive Edge Contraction
\item MWS: proposes an efficient implementation of this update rule (briefly mention the idea). In the Supplementary material we show that the algorithm they present can be seen as a special case of Unified Graph Agglomerative Clustering with absolute maximum update rule and that adding or not CLC does not change anything
\item Then new versions of avg/complete and single linkage clustering 
\item In this article we analyze only the simplest (and cheapest) types of update rules, but... Easily generalizable for: learned linkage criteria \cite{nunez2013machine}, something depending on node size \cite{felzenszwalb2004efficient}, quantiles, weighted average (WPGMA) and weighted sum (and related work by Paul), size rule by Thorsten
\item comment about the fact that sum is not really an ultra-metric-distance
\end{itemize}


% \begin{table*}[t]
%     \centering
%     \begin{subtable}[t!]{0.98\textwidth}\centering
%         \begin{tabular}{c | c }
%             \toprule\toprule
%             \makecell{Algorithm name} & \makecell{Algorithm description and \\linkage criteria}    \\
%             \midrule\midrule

%             Weighted Arithmetic Mean (WPGMA) & \thead{Assign a weighting $\alpha_e \in \mathbb{R}^+$, $\forall e \in E$ \\ \\ Linkage criteria: $w_{\mathrm{new}} = \frac{\alpha_1 w_1 +\alpha_2 w_2}{\alpha_1 + \alpha_2} $}  \\ \midrule
            
%             \makecell{Felzenszwalb Efficient \\Graph-based Image Segmentation \cite{felzenszwalb2004efficient}}  & \thead{Initially all edges have positive weights }  \\ \midrule

%             \makecell{Quantile Agglomeration Clustering (...?)}  & \thead{...}  \\ \midrule

%             \makecell{Graph-based active learning \\of agglomeration (GALA) \cite{nunez2013machine}}  & \thead{Assign set of edge features $\phi^{\mathrm{I}}_e$ and \\node features $\phi^{\mathrm{II}}_u$, $\forall u \in V$, $\forall e \in E$. \\ \\ A classifier $f$ with parameters $\theta$ predicts and updates\\ the cost of an edge: $w_e = f(\phi^{\mathrm{I}}_e, \phi^{\mathrm{II}}_u, \phi^{\mathrm{II}}_v; \theta)$, $\forall e_{uv} \in E$} \\ \midrule

%             % \makecell{$w_{\mathrm{new}}=w_{\tilde{e}}$,$\,
%             % \,$ where $\tilde{e}=\mathrm{arg}\max_{e\in \{e_{1},e_{2}\}} \left|w_e\right|$  }  & \thead{Mutex Watershed \cite{wolf2018mutex}} & \thead{Mutex Watershed \cite{wolf2018mutex}} \\ \midrule

%             % Arithmetic mean: $w_{\mathrm{new}} = (w_1+w_2) / 2 $                                 & \thead{Hierarchical Clustering \\ with Average Linkage (UPGMA)} & \thead{\textbf{NEW}}\\ \midrule

%             % Maximum: $w_{\mathrm{new}} = \max \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Single Linkage} & \thead{\textbf{NEW}}\\ \midrule

%             % Minimum: $w_{\mathrm{new}} = \min \{ w_1, w_2 \}  $                                 & \thead{Hierarchical Clustering \\ with Complete Linkage} & \thead{\textbf{NEW}}



            
%         \end{tabular}
%         % \caption{Linkage criteria}
%         \label{tab:linkage-criteria}
%     \end{subtable} 
%     \caption{Linkage criteria 2}
% \end{table*}






